import{_ as l,c as i,o as t,a4 as e}from"./chunks/framework.rIDq68an.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.11-Mq/MQ的应用场景与常见问题.md","filePath":"01-Dev/01.11-Mq/MQ的应用场景与常见问题.md"}'),a={name:"01-Dev/01.11-Mq/MQ的应用场景与常见问题.md"},o=e('<h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h2><blockquote><p>尽可能的减少通过引入中间件的方式来解决问题。会让系统的整体复杂性变高。 拿 Redis 举例子： 引入了 Redis 就要考虑数据一致性的问题。 拿 MQ 举例子： 引入了 MQ 就要考虑 MQ 的生产，消费，服务端的各个问题。</p><ul><li>生产者发消息没发出来怎么办、消费者没收到怎么办、服务端用着用着挂了怎么办。</li></ul></blockquote><ul><li>流量削峰: 并发改并行</li><li>异步处理: 对外域系统. 对自身系统.</li><li>应用解耦: RPC 改 MQ</li><li>消息通讯: <ul><li>本地缓存更新通知外域系统.</li><li>数据状态变更通知. (支付侧处理成功-&gt;佣金结算) (OFC 通知海外仓作业)</li></ul></li></ul><h2 id="mq-的消息模型" tabindex="-1">MQ 的消息模型 <a class="header-anchor" href="#mq-的消息模型" aria-label="Permalink to &quot;MQ 的消息模型&quot;">​</a></h2><ul><li>点对点 <strong>(管道)</strong></li><li>发布订阅 <strong>(观察者)</strong></li></ul><h2 id="常见八股问题" tabindex="-1">常见八股问题 <a class="header-anchor" href="#常见八股问题" aria-label="Permalink to &quot;常见八股问题&quot;">​</a></h2><p><strong>防止消息重复消费的解决方案</strong></p><ul><li>针对消息的唯一表示, 做数据库查询状态. (简单理解成乐观锁) <ul><li>不选择缓存的背景: 终究是要失效的, 远程缓存或者本地缓存, 存在发版/TTL 的问题.</li></ul></li></ul><p><strong>防止消息丢失</strong></p><ul><li>生产端丢了怎么办？ <ul><li>确认重试机制</li><li>try cache + while</li></ul></li><li>服务端丢了怎么办？ 服务端挂了怎么办？ <ul><li>MQ 自身提供了什么方案</li><li>如果没有提供，应该怎么不</li></ul></li><li>消费端丢了怎么办？ <ul><li>处理一半停电了怎么办</li></ul></li></ul><p><strong>顺序消费问题</strong></p><ul><li>状态机是否能够解决？</li><li>队列能否解决？</li><li>延迟消息能否使用？</li><li>往数据库根据排序写记录是否能够满足？</li></ul><p><strong>消息积压问题</strong></p><ul><li>简单粗暴： 加机器。</li><li>针对当前的业务场景，评估合理的消息量，如果出现了和预估不符的数据量，是否考虑消费者挂了？ 生产者一直在发重复消息？</li><li>是否是消费者消费的太慢？ <ul><li>业务代码写的是否规范？ 有没有循环 IO？有没有死锁？有没有阻塞？</li></ul></li><li>是否是生产者发的太快？ <ul><li>理论上，生产者的问题比较小。</li></ul></li></ul>',14),r=[o];function s(u,n,_,c,d,h){return t(),i("div",null,r)}const m=l(a,[["render",s]]);export{g as __pageData,m as default};

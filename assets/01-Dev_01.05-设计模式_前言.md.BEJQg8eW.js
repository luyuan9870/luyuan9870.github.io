import{_ as l,c as e,o as i,a4 as t}from"./chunks/framework.BG61BEI0.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.05-设计模式/前言.md","filePath":"01-Dev/01.05-设计模式/前言.md"}'),a={name:"01-Dev/01.05-设计模式/前言.md"},o=t('<p>--TODO 七大原则</p><h2 id="结构型" tabindex="-1">结构型 <a class="header-anchor" href="#结构型" aria-label="Permalink to &quot;结构型&quot;">​</a></h2><blockquote><p>本质: 处理类或者对象的组合</p><ol><li>类结构类型</li><li>采用继承机制来组合接口实现</li><li>对象结构类型</li><li>组合对象方式来实现新功能</li></ol></blockquote><ul><li>适配器 Adapter</li><li>桥梁模式 Bridge</li><li>装饰着模式 Decorator</li><li>门面模式 Facade</li><li>合成模式 Composite</li><li>享元模式 Flyweight</li><li>代理模式 Proxy</li></ul><h2 id="创建型" tabindex="-1">创建型 <a class="header-anchor" href="#创建型" aria-label="Permalink to &quot;创建型&quot;">​</a></h2><blockquote><p>本质: 对类的实例化进行抽象、封装了具体类的信息、隐藏了类的实例化过程</p></blockquote><ul><li>单例模式 Signleton</li><li>工厂方法模式 Factory Method</li><li>抽象工厂模式 Abstract Factory</li><li>建造者模式 Builder</li><li>原型模式 Prototype</li></ul><h2 id="行为型" tabindex="-1">行为型 <a class="header-anchor" href="#行为型" aria-label="Permalink to &quot;行为型&quot;">​</a></h2><blockquote><p>对在不通的对象之间划分职责和算法的抽象化 类的行为模式： 使用继承关系在几个类之间分配行为 对象的行为模式： 使用对象聚合的方式来分配行为</p></blockquote><ul><li>模板方法模式 Template Method</li><li>命令模式 Command</li><li>迭代器模式 Iterator</li><li>观察者模式 Observer</li><li>调度者模式 Mediator</li><li>状态模式 State</li><li>策略模式 Strategy</li><li>责任链模式 Chain of Responsibility</li><li>备忘录模式 Memento</li><li>解释器模式 Interpreter</li></ul><hr><p><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noreferrer">设计模式目录：22种设计模式</a></p>',12),r=[o];function n(c,s,d,_,p,h){return i(),e("div",null,r)}const b=l(a,[["render",n]]);export{m as __pageData,b as default};

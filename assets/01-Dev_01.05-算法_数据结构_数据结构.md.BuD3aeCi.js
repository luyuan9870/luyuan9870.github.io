import{_ as e,c as a,o as t,a4 as o}from"./chunks/framework.BG61BEI0.js";const r="/assets/image-20240607094316984.C4Cdmsrb.png",u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.05-算法/数据结构/数据结构.md","filePath":"01-Dev/01.05-算法/数据结构/数据结构.md"}'),l={name:"01-Dev/01.05-算法/数据结构/数据结构.md"},i=o('<h2 id="avl" tabindex="-1">AVL <a class="header-anchor" href="#avl" aria-label="Permalink to &quot;AVL&quot;">​</a></h2><blockquote><p>在 AVL 中, 任何节点的两个子树的高度差最大为 1，所以也叫高度平衡树（这个树的层级会很深）</p></blockquote><p><strong>特性</strong></p><ul><li>对于任何一个子树的 ROOT 节点，左边的数据一定同比右边的数据要小，反而亦之。</li><li>任何节点的两个子树的高度差最大为 1 <strong>数据失衡的处理方式</strong></li></ul><blockquote><p>数据失衡指的是在二叉树中，原本的树结构被打破了。需要重新调整树结构</p></blockquote><p>左旋、右旋。人话版本： （如果根节点被打破了，在老的树形结构中在右边，需要上升到根节点的 Root，这个过程叫右旋）</p><h2 id="rbt-红黑树" tabindex="-1">RBT(红黑树) <a class="header-anchor" href="#rbt-红黑树" aria-label="Permalink to &quot;RBT(红黑树)&quot;">​</a></h2><p>和 AVL 很像，数据失衡的处理多了一个变色</p><h2 id="b-树" tabindex="-1">B+树 <a class="header-anchor" href="#b-树" aria-label="Permalink to &quot;B+树&quot;">​</a></h2><h2 id="跳表" tabindex="-1">跳表 <a class="header-anchor" href="#跳表" aria-label="Permalink to &quot;跳表&quot;">​</a></h2><blockquote><p>本质上是一个 <code>链表</code> + <code>多级索引</code> + <code>指针</code> 的一个组合，其目的是为了降低链表的循环查找。通过多级索引的方式来间隔出与原始链表的数据差距，通过指针指向原始链表。</p></blockquote><p><img src="'+r+'" alt="" loading="lazy"></p><h2 id="相关参考" tabindex="-1">相关参考 <a class="header-anchor" href="#相关参考" aria-label="Permalink to &quot;相关参考&quot;">​</a></h2><p><a href="https://www.cnblogs.com/crazymakercircle/p/16320430.html" target="_blank" rel="noreferrer">红黑树（图解+秒懂+史上最全） - 疯狂创客圈 - 博客园</a></p><p><a href="https://oi-wiki.org/ds/skiplist/" target="_blank" rel="noreferrer">跳表 - OI Wiki</a></p><p><a href="https://www.cnblogs.com/Laymen/p/14084664.html" target="_blank" rel="noreferrer">跳表(SkipList)原理篇 - Laymen - 博客园</a></p>',16),s=[i];function c(n,p,h,d,_,b){return t(),a("div",null,s)}const k=e(l,[["render",c]]);export{u as __pageData,k as default};

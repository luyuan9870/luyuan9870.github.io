import{_ as a,c as e,o as t,a4 as r}from"./chunks/framework.BG61BEI0.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.01-Java/JVM/04-JVM的垃圾收集算法.md","filePath":"01-Dev/01.01-Java/JVM/04-JVM的垃圾收集算法.md","lastUpdated":1712823825000}'),o={name:"01-Dev/01.01-Java/JVM/04-JVM的垃圾收集算法.md"},l=r('<p>垃圾回收机制是怎么实现的</p><ul><li>基于可达性分析, 链路追踪能否定位到这个对象, 可以 说明正常, 不行 则GC</li></ul><h3 id="引用计数器" tabindex="-1">引用计数器 <a class="header-anchor" href="#引用计数器" aria-label="Permalink to &quot;引用计数器&quot;">​</a></h3><p>给每一个实例对象 设置一个计数器, 实例化一次+1 等计数器=0的时候 就会gc <strong>现在JVM不使用这种算法，效率不高</strong>。</p><h3 id="复制" tabindex="-1">复制 <a class="header-anchor" href="#复制" aria-label="Permalink to &quot;复制&quot;">​</a></h3><p>当一个对象经历15次GC都没有死, 那么就会进入老年代</p><h3 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to &quot;标记清除&quot;">​</a></h3><h3 id="标记整理" tabindex="-1">标记整理 <a class="header-anchor" href="#标记整理" aria-label="Permalink to &quot;标记整理&quot;">​</a></h3><h3 id="标记压缩" tabindex="-1">标记压缩 <a class="header-anchor" href="#标记压缩" aria-label="Permalink to &quot;标记压缩&quot;">​</a></h3><p>什么是FullGC</p>',10),i=[l];function n(_,s,h,c,d,p){return t(),e("div",null,i)}const f=a(o,[["render",n]]);export{m as __pageData,f as default};

import{_ as s,c as a,o as t,a4 as i}from"./chunks/framework.BG61BEI0.js";const n="/assets/206642b525724b559a09fa193940a322.BpFhr-d_.png",e="/assets/fe725834fb304a55a1bbae9aa70b7739.CKkSGU-s.png",l="/assets/1521ea3d3ed64dfa814c22b06d43ccc6.CK1F1tZN.png",p="/assets/5beab74efce64c5897d16f39db5e58f3.tHvjAtKk.png",o="/assets/44cbc243638f4544917f0aa44e440c82.Fj94bR_8.png",h="/assets/b81f9e21abd84b0aaa102f27c4007986.D_ehTuua.png",r="/assets/331b1e9000d34b5093ed5b60a24e0402.ez8GEPpP.png",d="/assets/874bcb40f36545279f8383408f50caf6.Dj8PNBJX.png",c="/assets/e99eed9d99934e339f3174dc81ece711.CqLvqSID.png",g="/assets/6f9efd6ca5b246629b25dbfec3d4a16c.BelyC5ml.png",k="/assets/e61e1fe960534b26b848708a753e05d6.DNbrvBs0.png",u="/assets/fb0e283d58494cc9993355a1fa6ddbee.VNKEkrOl.png",y="/assets/6ff517bede0043a2b37ff35c2b85f45e.Dk8a6UPI.png",b="/assets/51a12718671b4d368a4721cb7cff4b5c.DRBLsTpp.png",m="/assets/e428c317c70e4f01945955cd7f93a4d9.DGJHmcGS.png",E="/assets/ca90c6933c49450eba6bbb085a90bada.CJNjyD9D.png",v="/assets/aad767aa05404131b5617b415764f6ec.jdLiCRYk.png",f="/assets/d65086d93881426483bda40f576cd219.D-HqEd8Y.png",C="/assets/62dcc3fda07d4e71b5c0a63ab80a410c.l761q4qS.png",q="/assets/2c05bca3c4f344c497074dd768d1efef.CJUcdcn-.png",x="/assets/fcaee39e479c4d078f16ecb325619c53.YXzb639J.png",_="/assets/4be28005e8a244f7b357d277a9244dbe.CMgIA1vj.png",F="/assets/01493e1542304c32af3dd5e5dfdcaf39.BaELjDJT.png",M="/assets/f672e595715a452bb7a3abd3301c74d0.u0W_a5XM.png",X="/assets/06ce7f95993346b283c7f2f86fe1516f.sreeZLHC.png",D="/assets/f3a09e00012043baafea183e17291d48.C6xPLmGP.png",P="/assets/518fbc7a34494f1e91d914f5b8e2de8f.qrW0fQcg.png",S="/assets/b2a12fc243fa43248a12df586ee1df5a.BDvYWOif.png",j="/assets/9e2c9900320244d4a8ed33f3e64a117a.CrL9KClp.png",B="/assets/ac32aa9fcc89458eb5cac86209bdfa0a.DZiko8Zj.png",G="/assets/837bbf874f234b6f9a2f432c31eedbc6.B3yW0VIO.png",N=JSON.parse('{"title":"2023金九银十JVM面试突击班2","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.98-八股/2023金九银十面试突击班2_JVM.md","filePath":"01-Dev/01.98-八股/2023金九银十面试突击班2_JVM.md","lastUpdated":1712823825000}'),J={name:"01-Dev/01.98-八股/2023金九银十面试突击班2_JVM.md"},A=i('<h1 id="_2023金九银十jvm面试突击班2" tabindex="-1">2023金九银十JVM面试突击班2 <a class="header-anchor" href="#_2023金九银十jvm面试突击班2" aria-label="Permalink to &quot;2023金九银十JVM面试突击班2&quot;">​</a></h1><h3 id="如何确定一个对象是垃圾" tabindex="-1">如何确定一个对象是垃圾？ <a class="header-anchor" href="#如何确定一个对象是垃圾" aria-label="Permalink to &quot;如何确定一个对象是垃圾？&quot;">​</a></h3><blockquote><p><strong>要想进行垃圾回收，得先知道什么样的对象是垃圾。</strong></p></blockquote><ul><li>引用计数法 循环引用 引用--对象--数据</li></ul><p><strong>对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任何指针对其引用，它就是垃圾。</strong></p><p><code>弊端</code>:如果AB相互持有引用，导致永远不能被回收。 循环引用 内存泄露 --&gt;内存溢出</p><p><img src="'+n+'" alt="16461374670483019208ffy" loading="lazy"></p><ul><li>可达性分析/根搜索算法</li><li><ul><li>引用出一条单向的引用链，而在这个单向的引用链之上的对象，我们称之为GC的可达对象，不在引用链上的对象 我们称之为垃圾</li></ul></li></ul><p><strong>通过GC Root的引用，开始向下寻找，看某个对象是否可达</strong></p><p><img src="'+e+`" alt="image.png" loading="lazy"></p><blockquote><p><strong>能作为GC Root:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等。 GC ROOT是根对象？？？ 错误 GC root 的本质是一组你可以直接或者间接使用的活跃引用</strong></p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>虚拟机栈（栈帧中的本地变量表）中引用的对象。</span></span>
<span class="line"><span>方法区中类静态属性引用的对象。</span></span>
<span class="line"><span>方法区中常量引用的对象。</span></span>
<span class="line"><span>本地方法栈中JNI（即一般说的Native方法）引用的对象。  java   native  interface</span></span></code></pre></div><h2 id="垃圾收集算法" tabindex="-1">垃圾收集算法 <a class="header-anchor" href="#垃圾收集算法" aria-label="Permalink to &quot;垃圾收集算法&quot;">​</a></h2><blockquote><p><strong>已经能够确定一个对象为垃圾之后，接下来要考虑的就是回收，怎么回收呢？得要有对应的算法，下面介绍常见的垃圾回收算法。高效 健壮</strong></p></blockquote><h4 id="标记-清除-mark-sweep" tabindex="-1">标记-清除(Mark-Sweep) <a class="header-anchor" href="#标记-清除-mark-sweep" aria-label="Permalink to &quot;标记-清除(Mark-Sweep)&quot;">​</a></h4><ul><li><strong>标记</strong></li></ul><p><strong>找出内存中所有的存活对象，并且把它们标记出来</strong></p><p><img src="`+l+'" alt="image.png" loading="lazy"></p><ul><li><strong>清除</strong></li></ul><p><strong>清除掉被没有被标记需要回收的对象，释放出对应的内存空间</strong></p><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\26.png?lastModify=1646720640)<img src="'+p+`" alt="image.png" loading="lazy"></p><p><code>缺点</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程</span></span>
<span class="line"><span>序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</span></span>
<span class="line"><span>(1)标记和清除两个过程都比较耗时，效率不高</span></span>
<span class="line"><span>(2)会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</span></span></code></pre></div><h4 id="标记清除算法的衍生规则之分配-动态分区分配策略" tabindex="-1"><strong>标记清除算法的衍生规则之分配（动态分区分配策略）</strong> <a class="header-anchor" href="#标记清除算法的衍生规则之分配-动态分区分配策略" aria-label="Permalink to &quot;**标记清除算法的衍生规则之分配（动态分区分配策略）**&quot;">​</a></h4><p><strong>首次适应算法（Fisrt-fit）</strong></p><p>首次适应算法（Fisrt-fit）就是在遍历空闲链表的时候，一旦发现有大小大于等于需要的大小之后，就立即把该块分配给对象，并立即返回。</p><p><strong>最佳适应算法（Best-fit）</strong></p><p>最佳适应算法（Best-fit）就是在遍历空闲链表的时候，返回刚好等于需要大小的块。</p><p><strong>最差适应算法（Worst-fit）</strong></p><p>最差适应算法（Worst-fit）就是在遍历空闲链表的时候，找出空闲链表中最大的分块，将其分割给申请的对象，其目的就是使得分割后分块的最大化，以便下次好分配，不过这种分配算法很容易产生很多很小的分块，这些分块也不能被使用</p><h2 id="什么是stw-stop-the-world" tabindex="-1">什么是STW（stop the world）？ <a class="header-anchor" href="#什么是stw-stop-the-world" aria-label="Permalink to &quot;什么是STW（stop  the  world）？&quot;">​</a></h2><p>Stop-The-World 简称 STW</p><p>是在垃圾回收算法执行过程中,将jvm内存冻结,停顿的一种状态，在Stw情况下，容易出现两种现象：</p><p><strong>该回收的对象没有被回收</strong></p><p><strong>不该回收的对象被回收了</strong></p><p>在STW状态下,所有的线程都是停止运行的 - &gt;垃圾回收线程除外</p><p>当STW发生时,出了GC所需要的线程,其他的线程都将停止工作,中断了的线程知道GC线程结束才会继续任务</p><p>STW是不可避免的,垃圾回收算法的执行一定会出现STW,而我们最好的解决办法就是减少停顿的时间</p><p>GC各种算法的优化重点就是为了减少STW,这也是JVM调优的重点。</p><h4 id="标记-复制-mark-copying-效率很高-尽可能让我们的内存空间利用率增加" tabindex="-1">标记-复制(Mark-Copying) 效率很高 尽可能让我们的内存空间利用率增加 <a class="header-anchor" href="#标记-复制-mark-copying-效率很高-尽可能让我们的内存空间利用率增加" aria-label="Permalink to &quot;标记-复制(Mark-Copying)   效率很高    尽可能让我们的内存空间利用率增加&quot;">​</a></h4><p><strong>将内存划分为两块相等的区域，每次只使用其中一块，如下图所示：</strong></p><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\27.png?lastModify=1646720640)<img src="`+o+'" alt="image.png" loading="lazy"></p><p><strong>当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次清除掉。</strong></p><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\28.png?lastModify=1646720640)<img src="'+h+'" alt="image.png" loading="lazy"></p><p><code>缺点:</code>空间利用率降低。</p><h4 id="标记-整理-mark-compact-标记压缩算法" tabindex="-1">标记-整理(Mark-Compact) 标记压缩算法 <a class="header-anchor" href="#标记-整理-mark-compact-标记压缩算法" aria-label="Permalink to &quot;标记-整理(Mark-Compact)   标记压缩算法&quot;">​</a></h4><h4 id="随机整理-线性整理-滑动整理" tabindex="-1">随机整理 线性整理 滑动整理 <a class="header-anchor" href="#随机整理-线性整理-滑动整理" aria-label="Permalink to &quot;随机整理   线性整理    滑动整理&quot;">​</a></h4><blockquote><p><strong>复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都有100%存活的极端情况，所以老年代一般不能直接选用这种算法。</strong></p></blockquote><p><strong>标记过程仍然与&quot;标记-清除&quot;算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</strong></p><blockquote><p><strong>其实上述过程相对&quot;复制算法&quot;来讲，少了一个&quot;保留区&quot;</strong></p></blockquote><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\25.png?lastModify=1646720640)<img src="'+r+'" alt="image.png" loading="lazy"></p><p><strong>让所有存活的对象都向一端移动，清理掉边界意外的内存。</strong></p><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\29.png?lastModify=1646720640)<img src="'+d+'" alt="image.png" loading="lazy"></p><h3 id="分代收集算法" tabindex="-1">分代收集算法 <a class="header-anchor" href="#分代收集算法" aria-label="Permalink to &quot;分代收集算法&quot;">​</a></h3><blockquote><p><strong>既然上面介绍了3中垃圾收集算法，那么在堆内存中到底用哪一个呢？</strong></p></blockquote><p><strong>Young区：复制算法(对象在被分配之后，可能生命周期比较短，Young区复制效率比较高)</strong></p><p><strong>Old区：标记清除或标记整理(Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理)</strong></p><h2 id="其他算法" tabindex="-1">其他算法 <a class="header-anchor" href="#其他算法" aria-label="Permalink to &quot;其他算法&quot;">​</a></h2><p>增量回收算法：</p><p>垃圾回收其实就是对不需要的内存对象进行清理，前面提到的GC算法，无论哪种，基本都是过一段时间对所有的内存空间对象进行一次大扫除。 这种的GC缺点是一旦开始启动，管理程序可能就停止了，表现就是可能好多程序都没响应。可在服务端，这是大忌。增量式（incremental）出现就是解决这个问题的，这种垃圾回收采用和应用程序交替进行的方式来工作，表现就像是GC在不断的定时迭加操作。从而尽量减轻应用程序的停止时间，这就是增量式回收的特点。 在增量式回收里，比较容易接触到的就是三色标记算法。</p><h3 id="三色标记" tabindex="-1">三色标记 <a class="header-anchor" href="#三色标记" aria-label="Permalink to &quot;三色标记&quot;">​</a></h3><p>在并发标记的过程中，因为标记期间应用线程还在继续跑，对象间的引用可能发生变化，多标和漏标的情况就有可能发生。这里引入“三色标记”来给大家解释下，把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：</p><p><strong>灰色：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。</span></span></code></pre></div><p><strong>白色:</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>表示对象尚未被垃圾收集器访问过。 显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。</span></span></code></pre></div><p><strong>黑色：</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。</span></span></code></pre></div><p>标记过程：</p><p>1.初始时，所有对象都在 【白色集合】中；</p><p>2.将GC Roots 直接引用到的对象 挪到 【灰色集合】中；</p><p>3.从灰色集合中获取对象：</p><ol start="4"><li>将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；</li><li>将本对象 挪到 【黑色集合】里面。</li></ol><p>重复步骤3.4，直至【灰色集合】为空时结束。</p><p>结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收</p><p><img src="'+c+`" alt="16522703100363012464ffy" loading="lazy"></p><p><strong>多标-浮动垃圾</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>在并发标记过程中，如果由于方法运行结束导致部分局部变量(gcroot)被销毁，这个gc  root引用的对象之前又被扫描过 (被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为“浮动 垃圾”。浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>另外，针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色，本轮不会进行清除。这部分 对象期间可能也会变为垃圾，这也算是浮动垃圾的一部分。</span></span></code></pre></div><p><strong>漏标-读写屏障</strong></p><p>漏标只有<strong>同时满足</strong>以下两个条件时才会发生：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>条件一：灰色对象 断开了 白色对象的引用；即灰色对象 原来成员变量的引用 发生了变化。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>条件二：黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。</span></span></code></pre></div><p>漏标会导致被引用的对象被当成垃圾误删除，这是严重bug，必须解决，有两种解决方案： <strong>增量更新（Incremental Update） 和原始快照（Snapshot At The Beginning，SATB）</strong> 。</p><p><strong>增量更新</strong>就是当黑色对象<strong>插入新的指向</strong>白色对象的引用关系时， 就将这个新插入的引用记录下来， 等并发扫描结束之后， 再将这些记录过的引用关系中的黑色对象为根， 重新扫描一次。 这可以简化理解为， 黑色对象一旦新插入了指向白色对象的引用之后， 它就变回灰色对象了。</p><p><strong>原始快照</strong>就是当灰色对象要<strong>删除指向</strong>白色对象的引用关系时， 就将这个要删除的引用记录下来， 在并发扫描结束之后， 再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次，这样就能扫描到白色的对象，将白色对象直接标记为黑色(目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)</p><p>以上<strong>无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。</strong></p><p><strong>写屏障实现原始快照（SATB）：</strong> 当对象B的成员变量的引用发生变化时，比如引用消失（a.b.d = null），我们可以利用写屏障，将B原来成员变量的引用对象D记录下来：</p><p><strong>写屏障实现增量更新：</strong> 当对象A的成员变量的引用发生变化时，比如新增引用（a.d = d），我们可以利用写屏障，将A新的成员变量引用对象D 记录下来：</p><h2 id="垃圾收集器" tabindex="-1">垃圾收集器 <a class="header-anchor" href="#垃圾收集器" aria-label="Permalink to &quot;垃圾收集器&quot;">​</a></h2><blockquote><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p></blockquote><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\30.png?lastModify=1646736013)<img src="`+g+`" alt="image.png" loading="lazy"></p><ul><li>Serial</li></ul><p><strong>Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。</strong></p><p><strong>它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程。</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>优点：简单高效，拥有很高的单线程收集效率</span></span>
<span class="line"><span>缺点：收集过程需要暂停所有线程</span></span>
<span class="line"><span>算法：复制算法</span></span>
<span class="line"><span>适用范围：新生代</span></span>
<span class="line"><span>应用：Client模式下的默认新生代收集器</span></span></code></pre></div><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\31.png?lastModify=1646736013)<img src="`+k+'" alt="image.png" loading="lazy"></p><ul><li>Serial Old</li></ul><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用&quot;<strong>标记-整理算法</strong>&quot;，运行过程和Serial收集器一样。</p><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\32.png?lastModify=1646736013)<img src="'+u+`" alt="image.png" loading="lazy"></p><ul><li>ParNew</li></ul><p><strong>可以把这个收集器理解为Serial收集器的多线程版本。</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>优点：在多CPU时，比Serial效率高。</span></span>
<span class="line"><span>缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。</span></span>
<span class="line"><span>算法：复制算法</span></span>
<span class="line"><span>适用范围：新生代</span></span>
<span class="line"><span>应用：运行在Server模式下的虚拟机中首选的新生代收集器</span></span></code></pre></div><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\33.png?lastModify=1646736013)<img src="`+y+`" alt="image.png" loading="lazy"></p><ul><li>Parallel Scavenge</li></ul><p><strong>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的吞吐量</strong>。</p><blockquote><p><strong>吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)</strong></p><p><strong>比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%。</strong></p><p><strong>若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</strong></p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间，</span></span>
<span class="line"><span>-XX:GCRatio直接设置吞吐量的大小。</span></span></code></pre></div><ul><li>Parallel Old 停顿时间 吞吐量 百分比的数字</li></ul><p><strong>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法</strong>进行垃圾回收，也是更加关注系统的<strong>吞吐量</strong>。</p><ul><li>CMS</li></ul><blockquote><p><code>官网</code>： <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector" target="_blank" rel="noreferrer">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html#concurrent_mark_sweep_cms_collector</a></p><p><strong>CMS(Concurrent Mark Sweep)收集器是一种以获取</strong> <code>最短回收停顿时间</code>为目标的收集器。</p><p><strong>采用的是&quot;标记-清除算法&quot;,整个过程分为4步</strong></p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>(1)初始标记 CMS initial mark     标记GC Roots直接关联对象，不用Tracing，速度很快</span></span>
<span class="line"><span>(2)并发标记 CMS concurrent mark  进行GC Roots Tracing</span></span>
<span class="line"><span>(3)重新标记 CMS remark           修改并发标记因用户程序变动的内容</span></span>
<span class="line"><span>(4)并发清除 CMS concurrent sweep 清除不可达对象回收空间，同时有新垃圾产生，留着下次清理称为浮动垃圾</span></span></code></pre></div><blockquote><p><strong>由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。</strong></p></blockquote><p>![](file://E:\\桌面\\yzt\\笔记课件\\JVM\\3天JVM训练营\\资料+笔记\\images\\34.png?lastModify=1646736013)<img src="`+b+`" alt="image.png" loading="lazy"></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>优点：并发收集、低停顿</span></span>
<span class="line"><span>缺点：产生大量空间碎片、并发阶段会降低吞吐量</span></span></code></pre></div><h2 id="什么是记忆集" tabindex="-1">什么是记忆集？ <a class="header-anchor" href="#什么是记忆集" aria-label="Permalink to &quot;什么是记忆集？&quot;">​</a></h2><p>当我们进行young gc时，我们的<strong>gc roots除了常见的栈引用、静态变量、常量、锁对象、class对象</strong>这些常见的之外，如果 <strong>老年代有对象引用了我们的新生代对象</strong> ，那么老年代的对象也应该加入gc roots的范围中，但是如果每次进行young gc我们都需要扫描一次老年代的话，那我们进行垃圾回收的代价实在是太大了，因此我们引入了一种叫做记忆集的抽象数据结构来记录这种引用关系。</p><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的数据结构。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>如果我们不考虑效率和成本问题，我们可以用一个数组存储所有有指针指向新生代的老年代对象。但是如果这样的话我们维护成本就很好，打个比方，假如所有的老年代对象都有指针指向了新生代，那么我们需要维护整个老年代大小的记忆集，毫无疑问这种方法是不可取的。因此我们引入了卡表的数据结构</span></span></code></pre></div><h3 id="卡表" tabindex="-1">卡表 <a class="header-anchor" href="#卡表" aria-label="Permalink to &quot;卡表&quot;">​</a></h3><p>记忆集是我们针对于跨代引用问题提出的思想，而卡表则是针对于该种思想的具体实现。（可以理解为记忆集是结构，卡表是实现类）</p><p>[1字节，00001000，1字节，1字节]</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>在hotspot虚拟机中，卡表是一个字节数组，数组的每一项对应着内存中的某一块连续地址的区域，如果该区域中有引用指向了待回收区域的对象，卡表数组对应的元素将被置为1，没有则置为0；</span></span></code></pre></div><p>(1) 卡表是使用一个字节数组实现:CARD_TABLE[],每个元素对应着其标识的内存区域一块特定大小的内存块,称为&quot;卡页&quot;。hotSpot使用的卡页是2^9大小,即512字节</p><p>(2) 一个卡页中可包含多个对象,只要有一个对象的字段存在跨代指针,其对应的卡表的元素标识就变成1,表示该元素变脏,否则为0。GC时,只要筛选本收集区的卡表中变脏的元素加入GC Roots里。</p><p>卡表的使用图例</p><p><img src="`+m+'" alt="image.png" loading="lazy"></p><p>并发标记的时候，A对象发生了所在的引用发生了变化，所以A对象所在的块被标记为脏卡</p><p><img src="'+E+`" alt="image.png" loading="lazy"></p><p>继续往下到了重新标记阶段，修改对象的引用，同时清除脏卡标记。恩</p><h2 id="jvm常用参数有哪些" tabindex="-1">JVM常用参数有哪些？ <a class="header-anchor" href="#jvm常用参数有哪些" aria-label="Permalink to &quot;JVM常用参数有哪些？&quot;">​</a></h2><h2 id="jvm参数" tabindex="-1">JVM参数 <a class="header-anchor" href="#jvm参数" aria-label="Permalink to &quot;JVM参数&quot;">​</a></h2><h3 id="_3-1-1-标准参数" tabindex="-1">3.1.1 标准参数 <a class="header-anchor" href="#_3-1-1-标准参数" aria-label="Permalink to &quot;3.1.1 标准参数&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>-version</span></span>
<span class="line"><span>-help</span></span>
<span class="line"><span>-server</span></span>
<span class="line"><span>-cp</span></span></code></pre></div><p><img src="`+v+`" alt="aad767aa05404131b5617b415764f6ec.png" loading="lazy"></p><h3 id="_3-1-2-x参数" tabindex="-1">3.1.2 -X参数 <a class="header-anchor" href="#_3-1-2-x参数" aria-label="Permalink to &quot;3.1.2 -X参数&quot;">​</a></h3><blockquote><p>非标准参数，也就是在JDK各个版本中可能会变动</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>-Xint     解释执行</span></span>
<span class="line"><span>-Xcomp    第一次使用就编译成本地代码</span></span>
<span class="line"><span>-Xmixed   混合模式，JVM自己来决定</span></span></code></pre></div><p><img src="`+f+`" alt="image.png" loading="lazy"></p><h3 id="_3-1-3-xx参数" tabindex="-1">3.1.3 -XX参数 <a class="header-anchor" href="#_3-1-3-xx参数" aria-label="Permalink to &quot;3.1.3 -XX参数&quot;">​</a></h3><blockquote><p>使用得最多的参数类型</p><p>非标准化参数，相对不稳定，主要用于JVM调优和Debug</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>a.Boolean类型</span></span>
<span class="line"><span>格式：-XX:[+-]&lt;name&gt;            +或-表示启用或者禁用name属性</span></span>
<span class="line"><span>比如：-XX:+UseConcMarkSweepGC   表示启用CMS类型的垃圾回收器</span></span>
<span class="line"><span>	 -XX:+UseG1GC              表示启用G1类型的垃圾回收器</span></span>
<span class="line"><span>b.非Boolean类型</span></span>
<span class="line"><span>格式：-XX&lt;name&gt;=&lt;value&gt;表示name属性的值是value</span></span>
<span class="line"><span>比如：-XX:MaxGCPauseMillis=500</span></span></code></pre></div><h3 id="_3-1-4-其他参数" tabindex="-1">3.1.4 其他参数 <a class="header-anchor" href="#_3-1-4-其他参数" aria-label="Permalink to &quot;3.1.4 其他参数&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>-Xms1000M等价于-XX:InitialHeapSize=1000M</span></span>
<span class="line"><span>-Xmx1000M等价于-XX:MaxHeapSize=1000M</span></span>
<span class="line"><span>-Xss100等价于-XX:ThreadStackSize=100</span></span></code></pre></div><blockquote><p>所以这块也相当于是-XX类型的参数</p></blockquote><h3 id="_3-1-5-查看参数" tabindex="-1">3.1.5 查看参数 <a class="header-anchor" href="#_3-1-5-查看参数" aria-label="Permalink to &quot;3.1.5 查看参数&quot;">​</a></h3><blockquote><p>java -XX:+PrintFlagsFinal -version &gt; flags.txt</p></blockquote><p><img src="`+C+'" alt="image.png" loading="lazy"></p><p><img src="'+q+`" alt="image.png" loading="lazy"></p><blockquote><p>值得注意的是&quot;=&quot;表示默认值，&quot;:=&quot;表示被用户或JVM修改后的值 要想查看某个进程具体参数的值，可以使用jinfo，这块后面聊 一般要设置参数，可以先查看一下当前参数是什么，然后进行修改</p></blockquote><h3 id="_3-1-6-设置参数的常见方式" tabindex="-1">3.1.6 设置参数的常见方式 <a class="header-anchor" href="#_3-1-6-设置参数的常见方式" aria-label="Permalink to &quot;3.1.6 设置参数的常见方式&quot;">​</a></h3><ul><li>开发工具中设置比如IDEA，eclipse</li><li>运行jar包的时候:java -XX:+UseG1GC xxx.jar</li><li>web容器比如tomcat，可以在脚本中的进行设置</li><li>通过jinfo实时调整某个java进程的参数(参数只有被标记为manageable的flags可以被实时修改)</li></ul><h3 id="_3-1-7-实践和单位换算" tabindex="-1">3.1.7 实践和单位换算 <a class="header-anchor" href="#_3-1-7-实践和单位换算" aria-label="Permalink to &quot;3.1.7 实践和单位换算&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>1Byte(字节)=8bit(位)</span></span>
<span class="line"><span>1KB=1024Byte(字节)</span></span>
<span class="line"><span>1MB=1024KB</span></span>
<span class="line"><span>1GB=1024MB</span></span>
<span class="line"><span>1TB=1024GB</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>(1)设置堆内存大小和参数打印</span></span>
<span class="line"><span>-Xmx100M -Xms100M -XX:+PrintFlagsFinal</span></span>
<span class="line"><span>(2)查询+PrintFlagsFinal的值</span></span>
<span class="line"><span>:=true</span></span>
<span class="line"><span>(3)查询堆内存大小MaxHeapSize</span></span>
<span class="line"><span>:= 104857600</span></span>
<span class="line"><span>(4)换算</span></span>
<span class="line"><span>104857600(Byte)/1024=102400(KB)</span></span>
<span class="line"><span>102400(KB)/1024=100(MB)</span></span>
<span class="line"><span>(5)结论</span></span>
<span class="line"><span>104857600是字节单位</span></span></code></pre></div><h3 id="_3-1-8-常用参数含义" tabindex="-1">3.1.8 常用参数含义 <a class="header-anchor" href="#_3-1-8-常用参数含义" aria-label="Permalink to &quot;3.1.8 常用参数含义&quot;">​</a></h3><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:center;">含义</th><th style="text-align:center;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">-XX:CICompilerCount=3</td><td style="text-align:center;">最大并行编译数</td><td style="text-align:center;">如果设置大于1，虽然编译速度会提高，但是同样影响系统稳定性，会增加JVM崩溃的可能</td></tr><tr><td style="text-align:left;">-XX:InitialHeapSize=100M</td><td style="text-align:center;">初始化堆大小</td><td style="text-align:center;">简写-Xms100M</td></tr><tr><td style="text-align:left;">-XX:MaxHeapSize=100M</td><td style="text-align:center;">最大堆大小</td><td style="text-align:center;">简写-Xms100M</td></tr><tr><td style="text-align:left;">-XX:NewSize=20M</td><td style="text-align:center;">设置年轻代的大小</td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">-XX:MaxNewSize=50M</td><td style="text-align:center;">年轻代最大大小</td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">-XX:OldSize=50M</td><td style="text-align:center;">设置老年代大小</td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">-XX:MetaspaceSize=50M</td><td style="text-align:center;">设置方法区大小</td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">-XX:MaxMetaspaceSize=50M</td><td style="text-align:center;">方法区最大大小</td><td style="text-align:center;"></td></tr><tr><td style="text-align:left;">-XX:+UseParallelGC</td><td style="text-align:center;">使用UseParallelGC</td><td style="text-align:center;">新生代，吞吐量优先</td></tr><tr><td style="text-align:left;">-XX:+UseParallelOldGC</td><td style="text-align:center;">使用UseParallelOldGC</td><td style="text-align:center;">老年代，吞吐量优先</td></tr><tr><td style="text-align:left;">-XX:+UseConcMarkSweepGC</td><td style="text-align:center;">使用CMS</td><td style="text-align:center;">老年代，停顿时间优先</td></tr><tr><td style="text-align:left;">-XX:+UseG1GC</td><td style="text-align:center;">使用G1GC</td><td style="text-align:center;">新生代，老年代，停顿时间优先</td></tr><tr><td style="text-align:left;">-XX:NewRatio</td><td style="text-align:center;">新老生代的比值</td><td style="text-align:center;">比如-XX:Ratio=4，则表示新生代:老年代=1:4，也就是新生代占整个堆内存的1/5</td></tr><tr><td style="text-align:left;">-XX:SurvivorRatio</td><td style="text-align:center;">两个S区和Eden区的比值</td><td style="text-align:center;">比如-XX:SurvivorRatio=8，也就是(S0+S1):Eden=2:8，也就是一个S占整个新生代的1/10</td></tr><tr><td style="text-align:left;">-XX:+HeapDumpOnOutOfMemoryError</td><td style="text-align:center;">启动堆内存溢出打印</td><td style="text-align:center;">当JVM堆内存发生溢出时，也就是OOM，自动生成dump文件</td></tr><tr><td style="text-align:left;">-XX:HeapDumpPath=heap.hprof</td><td style="text-align:center;">指定堆内存溢出打印目录</td><td style="text-align:center;">表示在当前目录生成一个heap.hprof文件</td></tr><tr><td style="text-align:left;">-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:g1-gc.log</td><td style="text-align:center;">打印出GC日志</td><td style="text-align:center;">可以使用不同的垃圾收集器，对比查看GC情况</td></tr><tr><td style="text-align:left;">-Xss128k</td><td style="text-align:center;">设置每个线程的堆栈大小</td><td style="text-align:center;">经验值是3000-5000最佳</td></tr><tr><td style="text-align:left;">-XX:MaxTenuringThreshold=6</td><td style="text-align:center;">提升年老代的最大临界值</td><td style="text-align:center;">默认值为 15</td></tr><tr><td style="text-align:left;">-XX:InitiatingHeapOccupancyPercent</td><td style="text-align:center;">启动并发GC周期时堆内存使用占比</td><td style="text-align:center;">G1之类的垃圾收集器用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比. 值为 0 则表示”一直执行GC循环”. 默认值为 45.</td></tr><tr><td style="text-align:left;">-XX:G1HeapWastePercent</td><td style="text-align:center;">允许的浪费堆空间的占比</td><td style="text-align:center;">默认是10%，如果并发标记可回收的空间小于10%,则不会触发MixedGC。</td></tr><tr><td style="text-align:left;">-XX:MaxGCPauseMillis=200ms</td><td style="text-align:center;">G1最大停顿时间</td><td style="text-align:center;">暂停时间不能太小，太小的话就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。</td></tr><tr><td style="text-align:left;">-XX:ConcGCThreads=n</td><td style="text-align:center;">并发垃圾收集器使用的线程数量</td><td style="text-align:center;">默认值随JVM运行的平台不同而不同</td></tr><tr><td style="text-align:left;">-XX:G1MixedGCLiveThresholdPercent=65</td><td style="text-align:center;">混合垃圾回收周期中要包括的旧区域设置占用率阈值</td><td style="text-align:center;">默认占用率为 65%</td></tr><tr><td style="text-align:left;">-XX:G1MixedGCCountTarget=8</td><td style="text-align:center;">设置标记周期完成后，对存活数据上限为 G1MixedGCLIveThresholdPercent 的旧区域执行混合垃圾回收的目标次数</td><td style="text-align:center;">默认8次混合垃圾回收，混合回收的目标是要控制在此目标次数以内</td></tr><tr><td style="text-align:left;">-XX:G1OldCSetRegionThresholdPercent=1</td><td style="text-align:center;">描述Mixed GC时，Old Region被加入到CSet中</td><td style="text-align:center;">默认情况下，G1只把10%的Old Region加入到CSet中</td></tr><tr><td style="text-align:left;"></td><td style="text-align:center;"></td><td style="text-align:center;"></td></tr></tbody></table><h2 id="jvm常用命令有哪些" tabindex="-1">JVM常用命令有哪些 <a class="header-anchor" href="#jvm常用命令有哪些" aria-label="Permalink to &quot;JVM常用命令有哪些&quot;">​</a></h2><h3 id="jps" tabindex="-1">jps <a class="header-anchor" href="#jps" aria-label="Permalink to &quot;jps&quot;">​</a></h3><blockquote><p>查看java进程</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jps command lists the instrumented Java HotSpot VMs on the target system. The command is limited to reporting information on JVMs for which it has the access permissions.</span></span></code></pre></div><p><img src="`+x+`" alt="image.png" loading="lazy"></p><h3 id="jinfo" tabindex="-1">jinfo <a class="header-anchor" href="#jinfo" aria-label="Permalink to &quot;jinfo&quot;">​</a></h3><blockquote><p>（1）实时查看和调整JVM配置参数</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jinfo command prints Java configuration information for a specified Java process or core file or a remote debug server. The configuration information includes Java system properties and Java Virtual Machine (JVM) command-line flags.</span></span></code></pre></div><blockquote><p>（2）查看用法</p><p>jinfo -flag name PID 查看某个java进程的name属性的值</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jinfo -flag MaxHeapSize PID </span></span>
<span class="line"><span>jinfo -flag UseG1GC PID</span></span></code></pre></div><p><img src="`+_+`" alt="image.png" loading="lazy"></p><blockquote><p>（3）修改</p><p><strong>参数只有被标记为manageable的flags可以被实时修改</strong></p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jinfo -flag [+|-] PID</span></span>
<span class="line"><span>jinfo -flag &lt;name&gt;=&lt;value&gt; PID</span></span></code></pre></div><blockquote><p>（4）查看曾经赋过值的一些参数</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jinfo -flags PID</span></span></code></pre></div><p><img src="`+F+'" alt="image.png" loading="lazy"></p><h3 id="jstat" tabindex="-1">jstat <a class="header-anchor" href="#jstat" aria-label="Permalink to &quot;jstat&quot;">​</a></h3><blockquote><p>（1）查看虚拟机性能统计信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jstat command displays performance statistics for an instrumented Java HotSpot VM. The target JVM is identified by its virtual machine identifier, or vmid option.</span></span></code></pre></div><blockquote><p>（2）查看类装载信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jstat -class PID 1000 10   查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次</span></span></code></pre></div><p><img src="'+M+'" alt="image.png" loading="lazy"></p><blockquote><p>（3）查看垃圾收集信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jstat -gc PID 1000 10</span></span></code></pre></div><p><img src="'+X+'" alt="image.png" loading="lazy"></p><h3 id="jstack" tabindex="-1">jstack <a class="header-anchor" href="#jstack" aria-label="Permalink to &quot;jstack&quot;">​</a></h3><blockquote><p>（1）查看线程堆栈信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jstack command prints Java stack traces of Java threads for a specified Java process, core file, or remote debug server.</span></span></code></pre></div><blockquote><p>（2）用法</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jstack PID</span></span></code></pre></div><p><img src="'+D+`" alt="image.png" loading="lazy"></p><blockquote><p>(4)排查死锁案例</p></blockquote><ul><li>DeadLockDemo</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//运行主类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeadLockDemo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DeadLock d1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeadLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DeadLock d2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeadLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread t1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d1);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread t2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d2);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        t1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        t2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//定义锁对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object obj1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object obj2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//死锁代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeadLock</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> flag;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    DeadLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.flag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flag;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flag) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyLock.obj1) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;----if获得obj1锁&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyLock.obj2) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;----if获得obj2锁&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyLock.obj2) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;----否则获得obj2锁&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyLock.obj1) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;----否则获得obj1锁&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>运行结果</li></ul><p><img src="`+P+'" alt="image.png" loading="lazy"></p><ul><li>jstack分析</li></ul><p><img src="'+S+'" alt="image.png" loading="lazy"></p><blockquote><p>把打印信息拉到最后可以发现 <img src="'+j+`" alt="9e2c9900320244d4a8ed33f3e64a117a.png" loading="lazy"></p></blockquote><h3 id="jmap" tabindex="-1">jmap <a class="header-anchor" href="#jmap" aria-label="Permalink to &quot;jmap&quot;">​</a></h3><blockquote><p>（1）生成堆转储快照</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jmap command prints shared object memory maps or heap memory details of a specified process, core file, or remote debug server.</span></span></code></pre></div><blockquote><p>（2）打印出堆内存相关信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jmap -heap PID</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jinfo -flag UsePSAdaptiveSurvivorSizePolicy 35352</span></span>
<span class="line"><span>-XX:SurvivorRatio=8</span></span></code></pre></div><p><img src="`+B+'" alt="ac32aa9fcc89458eb5cac86209bdfa0a.png" loading="lazy"></p><blockquote><p>（3）dump出堆内存相关信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jmap -dump:format=b,file=heap.hprof PID</span></span></code></pre></div><p><img src="'+G+`" alt="837bbf874f234b6f9a2f432c31eedbc6.png" loading="lazy"></p><blockquote><p>（4）要是在发生堆内存溢出的时候，能自动dump出该文件就好了</p></blockquote><p>一般在开发中，JVM参数可以加上下面两句，这样内存溢出时，会自动dump出该文件</p><p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>设置堆内存大小: -Xms20M -Xmx20M</span></span>
<span class="line"><span>启动，然后访问localhost:9090/heap，使得堆内存溢出</span></span></code></pre></div>`,209),z=[A];function T(V,w,O,I,L,R){return t(),a("div",null,z)}const H=s(J,[["render",T]]);export{N as __pageData,H as default};

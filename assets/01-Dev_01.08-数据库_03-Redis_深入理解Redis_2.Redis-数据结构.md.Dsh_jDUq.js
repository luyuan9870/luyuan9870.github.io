import{_ as e,c as a,o as t,a4 as o}from"./chunks/framework.BG61BEI0.js";const q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.08-数据库/03-Redis/深入理解Redis/2.Redis-数据结构.md","filePath":"01-Dev/01.08-数据库/03-Redis/深入理解Redis/2.Redis-数据结构.md"}'),i={name:"01-Dev/01.08-数据库/03-Redis/深入理解Redis/2.Redis-数据结构.md"},l=o('<blockquote><p>Redis 虽然提供了多种数据类型，但是实际使用时都可以用 String 来做通过 Java 代码的序列化成 JSON 字符串存入 Redis。</p></blockquote><ul><li><h2 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h2><ul><li>String ：可以实现像计数器，分布式 ID，分布式锁，等业务场景 <ul><li>常用的命令： set、get 等</li><li>是一种最常用的数据类型，普通的 keyValue 数据都可以用 string 来存储</li><li>String 类型在 Redis 中就是用 C 构建的一个字符串</li></ul></li><li>Hash： 适合存储对象，KV 结构 <ul><li>常用命令：hget、hset、hgetall 等</li></ul></li><li>List： 有序可重复，是一个列表</li><li>Set：无序不可重复</li><li>ZSet： 可以实现排行榜</li></ul></li></ul><h3 id="string" tabindex="-1">String <a class="header-anchor" href="#string" aria-label="Permalink to &quot;String&quot;">​</a></h3><blockquote><p>Redis 字符串是最基本的 Redis 数据类型，表示字节序列。</p></blockquote><h3 id="list" tabindex="-1">List <a class="header-anchor" href="#list" aria-label="Permalink to &quot;List&quot;">​</a></h3><blockquote><p>Redis 列表是按插入顺序排序的字符串列表。</p></blockquote><h3 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-label="Permalink to &quot;Set&quot;">​</a></h3><blockquote><p>唯一字符串的无序集合，其作用类似于您最喜欢的编程语言中的集。 使用 Redis 集合，您可以在 O(1) 时间内添加、删除和测试是否存在（换句话说，无论集合元素的数量有多少）。</p></blockquote><h3 id="hash" tabindex="-1">Hash <a class="header-anchor" href="#hash" aria-label="Permalink to &quot;Hash&quot;">​</a></h3><blockquote><p>字段值对集合的记录类型。因此 Redis 哈希类似于 Java 中的 HashMap</p></blockquote><h3 id="zset-sortedset" tabindex="-1">ZSet （SortedSet） <a class="header-anchor" href="#zset-sortedset" aria-label="Permalink to &quot;ZSet （SortedSet）&quot;">​</a></h3><blockquote><p>唯一字符串的集合，它们通过每个字符串的关联分数来维护顺序</p></blockquote><p>底层是通过跳表来实现的，跳表的实现原理 <a href="./../../../01.05-算法/数据结构/数据结构.html">参考《数据结构》中 跳表章节</a> 。</p><h3 id="stream" tabindex="-1">Stream <a class="header-anchor" href="#stream" aria-label="Permalink to &quot;Stream&quot;">​</a></h3><blockquote><p>类似于仅附加日志。流有助于按事件发生的顺序记录事件，然后将它们联合起来进行处理。</p></blockquote><h3 id="geo-geospatial-index" tabindex="-1">Geo （Geospatial Index） <a class="header-anchor" href="#geo-geospatial-index" aria-label="Permalink to &quot;Geo （Geospatial Index）&quot;">​</a></h3><blockquote><p>对于查找给定地理半径或边界框内的位置非常有用。</p></blockquote><h3 id="bitmap" tabindex="-1">BitMap <a class="header-anchor" href="#bitmap" aria-label="Permalink to &quot;BitMap&quot;">​</a></h3><blockquote><p>对字符串执行按位运算。</p></blockquote><h3 id="bitfields" tabindex="-1">BitFields <a class="header-anchor" href="#bitfields" aria-label="Permalink to &quot;BitFields&quot;">​</a></h3><blockquote><p>对字符串值中的多个计数器进行编码。位域提供原子获取、设置和增量操作，并支持不同的溢出策略。</p></blockquote><h3 id="hyperloglog" tabindex="-1">HyperLogLog <a class="header-anchor" href="#hyperloglog" aria-label="Permalink to &quot;HyperLogLog&quot;">​</a></h3><blockquote><p>提供大型集合的基数（即元素数量）的概率估计</p></blockquote><h3 id="extension" tabindex="-1">Extension <a class="header-anchor" href="#extension" aria-label="Permalink to &quot;Extension&quot;">​</a></h3><blockquote><p>支持自定义，通过 Lua 脚本、或者使用模块 API</p></blockquote>',25),s=[l];function r(h,d,n,c,u,b){return t(),a("div",null,s)}const k=e(i,[["render",r]]);export{q as __pageData,k as default};

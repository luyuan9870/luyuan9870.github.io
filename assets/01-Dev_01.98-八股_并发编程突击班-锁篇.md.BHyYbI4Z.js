import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.BG61BEI0.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.98-八股/并发编程突击班-锁篇.md","filePath":"01-Dev/01.98-八股/并发编程突击班-锁篇.md"}'),e={name:"01-Dev/01.98-八股/并发编程突击班-锁篇.md"},t=n(`<p>并发编程突击班-锁篇</p><h4 id="_1、乐观锁cas和自旋锁的关系" tabindex="-1">1、乐观锁CAS和自旋锁的关系？ <a class="header-anchor" href="#_1、乐观锁cas和自旋锁的关系" aria-label="Permalink to &quot;1、乐观锁CAS和自旋锁的关系？&quot;">​</a></h4><p>你可以说，自旋锁是基于CAS实现的。</p><p>CAS没有自旋或者重试的效果，但是自旋锁是基于类似do-while的形式，不断尝试，直到成功位置。</p><p>CAS本质就是Unsafe类中的一个方法，他只会尝试一次，成功返回true，失败返回false。</p><hr><p><strong>CAS是怎么实现的（如果想再深入，看2023金三银四的并发编程突击班1，里面有详细说）</strong></p><p>CAS并不是在Java端实现的一个功能，而是在C++里面做的。</p><p>最终CAS会被翻译成一个指令。Atomic::cmpxchg，而这个指令是CPU原语，CPU认识这个指令。</p><h4 id="_2、cas的效果-以及java中cas操作实现" tabindex="-1">2、CAS的效果，以及Java中CAS操作实现？ <a class="header-anchor" href="#_2、cas的效果-以及java中cas操作实现" aria-label="Permalink to &quot;2、CAS的效果，以及Java中CAS操作实现？&quot;">​</a></h4><p>CAS就是比较和交换，就是将内存中的某一个值，从oldValue，替换为newValue。替换的过程是先用oldValue比较内存值，如果一致，就替换，然后返回true。如果比较不一致，返回false。</p><p>比较和交换这两个操作是一条指令实现的。</p><p>Java中想用CAS操作的话，无法直接通过new或者是他提供的静态方法，直接使用。会抛出java.lang.SecurityException: Unsafe异常。</p><p>想用的话，unsafe类的对象需要通过反射的方式拿到。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        MyTest test </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Unsafe unsafe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Field field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Unsafe.class.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDeclaredField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;theUnsafe&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        field.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAccessible</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        unsafe </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Unsafe) field.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 获取内存偏移量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> offset </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">objectFieldOffset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyTest.class.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getDeclaredField</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 执行CAS，这里的四个参数分别代表什么，你也要清楚~</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(unsafe.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compareAndSwapInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(test, offset, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">11</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(test.value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="_3、cas常见问题-处理方案" tabindex="-1">3、CAS常见问题，处理方案？ <a class="header-anchor" href="#_3、cas常见问题-处理方案" aria-label="Permalink to &quot;3、CAS常见问题，处理方案？&quot;">​</a></h4><p>ABA问题：不一定是问题，大多数情况下，只存在++，--这种操作时，无所谓你这个值是否被改过。对最终结果和业务没影响的，不需要考虑。</p><p>如果要求整个过程的变化不存在并发问题，不能出现ABA的情况，就必须追加类似版本号的效果，Java中也提供了AtmoicStampedReference</p><p>自旋次数过多：</p><ul><li>自旋一定次数，就挂起线程，别CAS了，浪费CPU资源。</li><li>采用分段锁的形式，不要专注于一个属性，如果业务允许，可以分开计算，最终汇总。</li></ul><p>CAS本质无法锁住一段代码，只能保证修改一个属性的原子性：But，ReentrantLock就是基于CAS的原子性类实现锁住一段代码的。</p><h4 id="_4、synchronized的锁状态变化" tabindex="-1">4、synchronized的锁状态变化？ <a class="header-anchor" href="#_4、synchronized的锁状态变化" aria-label="Permalink to &quot;4、synchronized的锁状态变化？&quot;">​</a></h4><p>无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁？是这么一步一步走过来的么？</p><p>其实状态不是这样一点一点来的。</p><p>无锁无法到偏向锁</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1692777284007/eef57ad541a04cc0a0efd484b17dcc70.png" alt="image.png" loading="lazy"></p><p><strong>这里整体是一个锁升级的过程，那存在锁降级么？</strong></p><p>偏向锁是可以到无锁状态的，偏向锁没有地儿存储hashcode之类的值，为了存储，要么升级到轻量级锁，存储到LockRecord里，要么降级为无锁，存在MarkWord里。</p><h4 id="_5、怎么介绍aqs" tabindex="-1">5、怎么介绍AQS？ <a class="header-anchor" href="#_5、怎么介绍aqs" aria-label="Permalink to &quot;5、怎么介绍AQS？&quot;">​</a></h4><p>先说清楚和JUC的关系以及说和JUC下其他类的关系，然后说内部的核心结构。你可以往你会的地方拐。</p><p>AQS本质就是JUC包下的一个抽象类，JUC包下的一些并发工具，并发集合，线程池，锁都是基于AQS作为基础类去实现的。</p><p>AQS里面有一个核心属性和两个核心的结构：</p><ul><li>volatile修改是，并且基于CAS修改的state属性。</li><li>由Node组成的一个双向链表，或者说叫同步队列。</li><li>由Node组成的一个单向链表，这个是用于实现类似synchronized的wait和notify的结构。</li></ul><h4 id="_6、reentrantlock的几种获取锁方式的区别" tabindex="-1">6、ReentrantLock的几种获取锁方式的区别？ <a class="header-anchor" href="#_6、reentrantlock的几种获取锁方式的区别" aria-label="Permalink to &quot;6、ReentrantLock的几种获取锁方式的区别？&quot;">​</a></h4><ul><li>lock</li><li>tryLock()</li><li>tryLock(time,unit)</li><li>lockInterruptibly</li></ul><p>lock方法：死等，如果那不到锁，就一直等，你interrupt中断了也一直等。</p><p>tryLock()方法：浅尝一下，试一下，就一下，拿到快乐的返回true，拿不到，返回false。</p><p>tryLock(time,unit)方法：尝试time.unit这么尝试时间，如果拿到了，返回true，时间到了，没拿到，返回false。如果在拿的过程中，线程中断了，就抛出异常。</p><p>lockInterruptibly方法：死等，如果那不到锁，就一直等，如果被interrupt中断了，抛出异常</p><h4 id="_7、aqs中node的几种状态" tabindex="-1">7、AQS中Node的几种状态？ <a class="header-anchor" href="#_7、aqs中node的几种状态" aria-label="Permalink to &quot;7、AQS中Node的几种状态？&quot;">​</a></h4><p>Node有5种状态，1，0，-1，-2，-3</p><ul><li>1：代表当前Node已经取消了，不排队了。</li><li>0：代表代表默认状态，啥事没有~</li><li>-1：代表当前节点的next Node挂起了，需要被唤醒</li><li>-2：当前Node被await挂起了，扔到了Condition的单向链表里。</li><li>-3：传播用的，共享资源里会用到，读线程拿到锁资源后，如果同步队列里排的是共享资源Node，那就继续唤醒。</li></ul><hr><p><strong>共享锁和互斥锁：</strong></p><p>互斥锁是同一时间点，只能有一个线程持有。</p><p>共享锁是同一时间点，可以有多个线程同时持有。</p><h4 id="_8、aqs中取消节点的过程" tabindex="-1">8、AQS中取消节点的过程？ <a class="header-anchor" href="#_8、aqs中取消节点的过程" aria-label="Permalink to &quot;8、AQS中取消节点的过程？&quot;">​</a></h4><p>想拿资源的线程在排队，但是不想排了，需要取消排队的Node。</p><p>1、将排队的Node里的线程设置为null</p><p>2、跳过取消的前继节点，找到有效节点连接上</p><p>3、将Node的状态设置为1，代表取消</p><p>4、后续节点操作，分为几种情况</p><ul><li>取消的节点是tail：直接更换尾节点为有效的前继节点</li><li>取消的节点不是head.next：确保后继节点可以被唤醒，将前继节点设置为-1。</li><li>取消的节点是head.next：直接唤醒后继节点。</li></ul><p>5、将取消的节点的next指向自己。</p><h4 id="_9、aqs唤醒时-head-next有问题时-为啥从后往前找" tabindex="-1">9、AQS唤醒时，head.next有问题时，为啥从后往前找 <a class="header-anchor" href="#_9、aqs唤醒时-head-next有问题时-为啥从后往前找" aria-label="Permalink to &quot;9、AQS唤醒时，head.next有问题时，为啥从后往前找&quot;">​</a></h4><p>因为如果next后取消的节点，取消节点会将next指向自己，直接找不到了。</p><p>另外，节点加入的顺序，是先连接prev，再连接tail，最后将前继节点的next指向自己。</p><p>在AQS里，prev指针始终是正确的，next说不定。</p><h4 id="_10、reentrantreadwritelock读写锁出现的目的" tabindex="-1">10、ReentrantReadWriteLock读写锁出现的目的？ <a class="header-anchor" href="#_10、reentrantreadwritelock读写锁出现的目的" aria-label="Permalink to &quot;10、ReentrantReadWriteLock读写锁出现的目的？&quot;">​</a></h4><p>首先，读写锁能解决的，互斥锁肯定能解决，但是，互斥锁的效率可能比较低。</p><p>比如说有一个业务，平均下来，10次读操作，1次写操作。</p><p>如果用互斥锁，可以保证线程安全，但是10次读操作也需要一个一个来。</p><p>但是，读读操作没有线程安全问题。</p><p>但是只要涉及到了写操作，比如读写操作，需要保证线程安全。只要有写线程，就必须满足互斥性。</p><p>所以JUC下就提供了一个ReentrantReadWriteLock，读写锁。这个锁的特点，就是读读可以一起操作，但是只要涉及到了写操作，就必须保证互斥。</p><h4 id="_11、reentrantreadwritelock如何基于aqs实现的" tabindex="-1">11、ReentrantReadWriteLock如何基于AQS实现的？ <a class="header-anchor" href="#_11、reentrantreadwritelock如何基于aqs实现的" aria-label="Permalink to &quot;11、ReentrantReadWriteLock如何基于AQS实现的？&quot;">​</a></h4><p>lock锁，无论是读锁还是写锁，都是基于state属性判断的。</p><p>state是int，占32个bit为，将高16为，作为读锁的标识，低16位，作为写锁的标识。</p><p>如果线程要拿读锁，只需要确认没有写线程在持有写锁资源，并且队列中的head.next不是写锁（解决写锁饥饿问题），就可以直接获取读锁资源。</p><p>写锁需要确保没有读线程在持有读锁，并且没有其他线程在持有写锁，写锁才能拿到锁资源。</p>`,70),l=[t];function p(h,k,r,d,o,E){return a(),i("div",null,l)}const y=s(e,[["render",p]]);export{g as __pageData,y as default};

import{_ as e,c as i,o as l,a4 as p}from"./chunks/framework.BG61BEI0.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.08-数据库/03-Redis/深入理解Redis/5.Redis-持久化与淘汰机制.md","filePath":"01-Dev/01.08-数据库/03-Redis/深入理解Redis/5.Redis-持久化与淘汰机制.md"}'),s={name:"01-Dev/01.08-数据库/03-Redis/深入理解Redis/5.Redis-持久化与淘汰机制.md"},a=p('<h4 id="内存淘汰策略" tabindex="-1">内存淘汰策略 <a class="header-anchor" href="#内存淘汰策略" aria-label="Permalink to &quot;内存淘汰策略&quot;">​</a></h4><p>Redis 在 64 位系统中默认是不限制内存大小的，在 32 位系统中默认是最大 3 GB，可以通过 redis. Conf 配置文件中的 maxmemory 参数设置最大的内存值。或者是通过 config set maxmemory</p><p>Redis 有两种内存淘汰策略</p><ol><li><p>第一种是 TTL 过期删除策略</p></li><li><p>根据过期时间，采用懒删除和定时删除的两种模式</p></li><li><p>懒删除就是当 TTL 过期的时候，不会立即删除当前 key，而是当访问这个 key 的时候去判断当前的过期时间是否已经过期</p></li><li><p>定时删除每个一段时间 Redis 会扫描一定数量的 key，当过期 key 的数量超过了扫描数量的 25%就会删除其中已经过期的 key</p></li><li><p>第二种是内存淘汰的策略</p></li></ol><ul><li><p>Redis 的过期删除策略，缓存过期之后是立即删除吗？ 如果不是那么它底层是怎么进行删除的</p></li><li><p>Redis 不会立即删除过期内存，它采用的是惰性删除和定时删除，因为如果是实时删除的话会占用较高的 CPU 资源</p></li><li><p>惰性删除： 只有当访问这个 key 的时候，才会判断这个 key 有没有过期。这种策略极大的节省了 CPU 的资源，但是对内存不是很友好，极端情况下可能会有大量的过期缓存没有被再次访问，导致不会被清除从而造成了内存的浪费</p></li><li><p>定时删除： 每隔一段时间，Redis 会扫描一定数量（设置了过期时间的）key，并清除其中已经过期的 key。使 CPU 和内存达到平衡</p></li><li><p>Redis 的拒绝策略 Redis 共有八种拒绝策略 LRU 算法： 淘汰距离上次使用最早，次数最少的 key</p></li><li><p>默认是 noeviction 不回收当 Redis 的内存超过使用配置的阈值时，在添加新的内存它会返回错误，不会驱逐任何的 key</p></li><li><p>Volatile-lru （推荐的拒绝策略）：使用 LRU 算法进行数据淘汰（淘汰距离上次使用最早，并且次数最少的 key），只淘汰设定了有效期的 key</p></li><li><p>Allkeys-lru：使用 LRU 算法进行数据淘汰，这种拒绝策略可以淘汰所有的 key</p></li><li><p>AllKeys-LFU ： 淘汰所有 key 中使用频率最少的 key</p></li><li><p>Allkeys-Random： 随机淘汰数据，这种拒绝策略可以淘汰所有的 key</p></li><li><p>Volatile-Random ： 随机淘汰数据，只淘汰设定了有效期的 key</p></li><li><p>Volatile-TTL： 淘汰剩余有效期最短的 key</p></li><li><p>Volatile-LFU ：淘汰所有配置了过期时间，里面使用频率最少的 key</p></li></ul>',5),t=[a];function o(d,_,r,n,k,y){return l(),i("div",null,t)}const m=e(s,[["render",o]]);export{c as __pageData,m as default};

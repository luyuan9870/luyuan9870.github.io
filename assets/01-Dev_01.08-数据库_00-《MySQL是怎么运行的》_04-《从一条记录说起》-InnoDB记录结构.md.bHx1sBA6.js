import{_ as o,E as t,c as d,m as a,a as s,J as i,w as n,a4 as l,o as h}from"./chunks/framework.BG61BEI0.js";const K=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.08-数据库/00-《MySQL是怎么运行的》/04-《从一条记录说起》-InnoDB记录结构.md","filePath":"01-Dev/01.08-数据库/00-《MySQL是怎么运行的》/04-《从一条记录说起》-InnoDB记录结构.md"}'),c={name:"01-Dev/01.08-数据库/00-《MySQL是怎么运行的》/04-《从一条记录说起》-InnoDB记录结构.md"},p=a("code",null,"Mysql",-1),_=a("code",null,"sql",-1),r=a("code",null,"mysql",-1),k=a("strong",null,"那么表中的数据存储到哪里了? 存储的是什么格式? 怎么存储的? 又是怎么访问这些数据的?",-1),u=a("code",null,"Mysql",-1),y=a("code",null,"存储引擎",-1),f=a("code",null,"Mysql",-1),F=a("code",null,"InnoDB",-1),g=a("code",null,"MyISAM",-1),B=a("code",null,"Memory",-1),E=a("h2",{id:"innodb-页简介",tabindex:"-1"},[s("InnoDB 页简介 "),a("a",{class:"header-anchor",href:"#innodb-页简介","aria-label":'Permalink to "InnoDB 页简介"'},"​")],-1),m=a("code",null,"InnoDB",-1),b=a("code",null,"Innodb",-1),C=a("code",null,"预读",-1),q=a("code",null,"Mysql",-1),D=a("code",null,"预读",-1),A=a("code",null,"InnoDB",-1),I=a("code",null,"页",-1),T=a("code",null,"16KB",-1),M=a("code",null,"页",-1),S=l(`<h2 id="innodb-行格式" tabindex="-1">InnoDB 行格式 <a class="header-anchor" href="#innodb-行格式" aria-label="Permalink to &quot;InnoDB 行格式&quot;">​</a></h2><blockquote><p>我们一般向数据库 <code>insert</code> 一条数据都是以行格式去新增数据的. 这些记录在磁盘上的存储方式为 <code>行格式</code> 或者叫 <code>记录格式</code><code>InnoDB</code> 在设计之初做了四种不同类型的行格式, <code>紧凑 Compact</code>, <code>压缩 Compressed</code> , <code>动态 Dynamic (默认)</code> , <code>冗余 Redundant</code>.</p></blockquote><p>查看 <code>Mysql</code> 默认的行格式</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mysql&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> show</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> variables</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> like</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;innodb_default_row_format&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+---------------------------+---------+</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Variable_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">             |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   |</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+---------------------------+---------+</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> innodb_default_row_format</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dynamic</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+---------------------------+---------+</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> row</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> in</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (0.05 </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">sec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mysql&gt;</span></span></code></pre></div><p>我们可以在创建/修改表的语句上指定行格式</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">create</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 表名</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> row_format </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 行格式名称[Compact,Compressed,Dynamic,Redundant]</span></span></code></pre></div><h3 id="compact-行格式" tabindex="-1">Compact 行格式 <a class="header-anchor" href="#compact-行格式" aria-label="Permalink to &quot;Compact 行格式&quot;">​</a></h3><p>Compact 行格式一条完整的记录由 <code>记录的额外信息</code>, <code>记录的真实数据</code> 两大部分组成.</p><h4 id="记录的额外信息" tabindex="-1">记录的额外信息 <a class="header-anchor" href="#记录的额外信息" aria-label="Permalink to &quot;记录的额外信息&quot;">​</a></h4>`,9),v=a("strong",null,"为了描述当前这行信息不得不额外做的记录信息",-1),P=l('<h5 id="变长字段长度列表" tabindex="-1">变长字段长度列表 <a class="header-anchor" href="#变长字段长度列表" aria-label="Permalink to &quot;变长字段长度列表&quot;">​</a></h5><blockquote><p>我们知道 <code>MySQL</code> 支持一些变长的数据类型，比如 <code>VARCHAR(M)</code>、<code>VARBINARY(M)</code>、各种 <code>TEXT</code> 类型，各种 <code>BLOB</code> 类型，我们也可以把拥有这些数据类型的列称为 <code>变长字段</code>，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 <code>MySQL</code> 服务器搞懵，所以这些变长字段占用的存储空间分为两部分：</p></blockquote>',2),V=a("li",null,"真正的数据内容 (可变字段)",-1),x=a("code",null,"Compact",-1),N=l('<h5 id="null-值列表" tabindex="-1">Null 值列表 <a class="header-anchor" href="#null-值列表" aria-label="Permalink to &quot;Null 值列表&quot;">​</a></h5><h5 id="记录头信息" tabindex="-1">记录头信息 <a class="header-anchor" href="#记录头信息" aria-label="Permalink to &quot;记录头信息&quot;">​</a></h5><hr><p>参考 <a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/04-%E4%BB%8E%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E8%AF%B4%E8%B5%B7-InnoDB%E8%AE%B0%E5%BD%95%E7%BB%93%E6%9E%84" target="_blank" rel="noreferrer">《MySQL 是怎样运行的：从根儿上理解 MySQL》</a></p>',4);function R(L,w,Q,$,O,J){const e=t("font");return h(),d("div",null,[a("blockquote",null,[a("p",null,[s("至今为止, "),p,s(" 还是一个黑盒, 在使用层面我们只需要在客户端编写好 "),_,s(" 发送给 "),r,s(" 服务端之后等待服务器的返回结果. "),k,u,s(" 服务端的数据存储和处理是由 "),y,s(" 来进行处理的, "),f,s(" 中由有很多不同的存储引擎 "),F,s(),g,s(" 等, 这些不同的存储引擎一般是由不同的人为实现不同的特性而开发的. "),i(e,{color:"#ff0000"},{default:n(()=>[s("真实数据在不同的存储引擎上存放的格式也是不同的")]),_:1}),s(", 甚至有的存储引擎压根就没有做数据刷盘的操作, 例如 "),B,s(" 这种引擎直接就是在内存上进行操作的, 当 Mysql 服务端发生关闭/重启时数据就全部丢掉了.")])]),E,a("blockquote",null,[a("p",null,[m,s(" 是一个将数据处理到磁盘中的存储引擎, 也就是它会把数据库持久化到磁盘中, 这个操作是在内存中实现的. 而内存与磁盘的读写速度差距很大. "),b,s(" 又是如何解决这个问题的呢?, 为了提升效率, 尽量减少磁盘 IO. 读取磁盘时往往不是严格的按需读取, 而是每次都会 "),C,s(" 即使当前只需要 1 个字节的数据, "),q,s(" 也是会从这个位置开始顺序往后读取一定长度的数据放入内存,这个称之为 "),D,s(". "),A,s(" 的基本单元叫 "),I,s(" 每一页数据"),i(e,{color:"#ff0000"},{default:n(()=>[s("一般")]),_:1}),s("有 "),T,s(" (默认), 不管是写入到内存中还是读取到磁盘中, 都是以 "),M,s(" 来作为基本单元的数据操作")])]),S,a("blockquote",null,[a("p",null,[s("Mysql "),v,s(", 总共有三大类 "),i(e,{color:"#ffff00"},{default:n(()=>[s("变长字段长度列表")]),_:1}),s(" 、"),i(e,{color:"#ffff00"},{default:n(()=>[s("Null 值列表")]),_:1}),s(" 、"),i(e,{color:"#ffff00"},{default:n(()=>[s("记录头信息")]),_:1})])]),P,a("ol",null,[V,a("li",null,[s("占用的字节数 (长度) 在 "),x,s(" 中, 把所有变长字段的真实数据、占用的字节长度都存放在记录的开头部位，从而形成一个变"),i(e,{color:"#ffff00"},{default:n(()=>[s("长字段长度列表")]),_:1}),s(" , 每个变长字段数据及其占用的字节数"),i(e,{color:"#ffff00"},{default:n(()=>[s("按照列的顺序逆序存放")]),_:1}),s(". 所有的数据都是"),i(e,{color:"#ffff00"},{default:n(()=>[s("逆序存放")]),_:1}),s("的 把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放")])]),N])}const X=o(c,[["render",R]]);export{K as __pageData,X as default};

import{_ as s,c as a,o as i,a4 as n}from"./chunks/framework.BG61BEI0.js";const y=JSON.parse('{"title":"金九银十面试突击班3","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.98-八股/金九银十面试突击班3.md","filePath":"01-Dev/01.98-八股/金九银十面试突击班3.md"}'),p={name:"01-Dev/01.98-八股/金九银十面试突击班3.md"},t=n(`<h1 id="金九银十面试突击班3" tabindex="-1">金九银十面试突击班3 <a class="header-anchor" href="#金九银十面试突击班3" aria-label="Permalink to &quot;金九银十面试突击班3&quot;">​</a></h1><h2 id="jvm常用命令有哪些-你是怎么使用的" tabindex="-1">JVM常用命令有哪些，你是怎么使用的 <a class="header-anchor" href="#jvm常用命令有哪些-你是怎么使用的" aria-label="Permalink to &quot;JVM常用命令有哪些，你是怎么使用的&quot;">​</a></h2><h3 id="jps" tabindex="-1">jps <a class="header-anchor" href="#jps" aria-label="Permalink to &quot;jps&quot;">​</a></h3><blockquote><p>查看java进程</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jps command lists the instrumented Java HotSpot VMs on the target system. The command is limited to reporting information on JVMs for which it has the access permissions.</span></span></code></pre></div><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/fcaee39e479c4d078f16ecb325619c53.png" alt="image.png" loading="lazy"></p><h3 id="jinfo" tabindex="-1">jinfo <a class="header-anchor" href="#jinfo" aria-label="Permalink to &quot;jinfo&quot;">​</a></h3><blockquote><p>（1）实时查看和调整JVM配置参数</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jinfo command prints Java configuration information for a specified Java process or core file or a remote debug server. The configuration information includes Java system properties and Java Virtual Machine (JVM) command-line flags.</span></span></code></pre></div><blockquote><p>（2）查看用法</p><p>jinfo -flag name PID 查看某个java进程的name属性的值</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jinfo -flag MaxHeapSize PID </span></span>
<span class="line"><span>jinfo -flag UseG1GC PID</span></span></code></pre></div><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/4be28005e8a244f7b357d277a9244dbe.png" alt="image.png" loading="lazy"></p><blockquote><p>（3）修改</p><p><strong>参数只有被标记为manageable的flags可以被实时修改</strong></p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jinfo -flag [+|-] PID</span></span>
<span class="line"><span>jinfo -flag &lt;name&gt;=&lt;value&gt; PID</span></span></code></pre></div><blockquote><p>（4）查看曾经赋过值的一些参数</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jinfo -flags PID</span></span></code></pre></div><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/01493e1542304c32af3dd5e5dfdcaf39.png" alt="image.png" loading="lazy"></p><h3 id="jstat" tabindex="-1">jstat <a class="header-anchor" href="#jstat" aria-label="Permalink to &quot;jstat&quot;">​</a></h3><blockquote><p>（1）查看虚拟机性能统计信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jstat command displays performance statistics for an instrumented Java HotSpot VM. The target JVM is identified by its virtual machine identifier, or vmid option.</span></span></code></pre></div><blockquote><p>（2）查看类装载信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jstat -class PID 1000 10   查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次</span></span></code></pre></div><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/f672e595715a452bb7a3abd3301c74d0.png" alt="image.png" loading="lazy"></p><blockquote><p>（3）查看垃圾收集信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jstat -gc PID 1000 10</span></span></code></pre></div><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/06ce7f95993346b283c7f2f86fe1516f.png" alt="image.png" loading="lazy"></p><h3 id="jstack" tabindex="-1">jstack <a class="header-anchor" href="#jstack" aria-label="Permalink to &quot;jstack&quot;">​</a></h3><blockquote><p>（1）查看线程堆栈信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jstack command prints Java stack traces of Java threads for a specified Java process, core file, or remote debug server.</span></span></code></pre></div><blockquote><p>（2）用法</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jstack PID</span></span></code></pre></div><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/f3a09e00012043baafea183e17291d48.png" alt="image.png" loading="lazy"></p><blockquote><p>(4)排查死锁案例</p></blockquote><ul><li>DeadLockDemo</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//运行主类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeadLockDemo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DeadLock d1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeadLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        DeadLock d2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeadLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread t1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d1);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread t2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d2);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        t1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        t2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//定义锁对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object obj1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object obj2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//死锁代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DeadLock</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> flag;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    DeadLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">boolean</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> flag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.flag</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flag;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flag) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyLock.obj1) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;----if获得obj1锁&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyLock.obj2) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;----if获得obj2锁&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyLock.obj2) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;----否则获得obj2锁&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(MyLock.obj1) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;----否则获得obj1锁&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>运行结果</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/518fbc7a34494f1e91d914f5b8e2de8f.png" alt="image.png" loading="lazy"></p><ul><li>jstack分析</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/b2a12fc243fa43248a12df586ee1df5a.png" alt="image.png" loading="lazy"></p><blockquote><p>把打印信息拉到最后可以发现</p></blockquote><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/4f9780d7efe84b22a3b83f40370c1686.png" alt="image.png" loading="lazy"></p><h3 id="jmap" tabindex="-1">jmap <a class="header-anchor" href="#jmap" aria-label="Permalink to &quot;jmap&quot;">​</a></h3><blockquote><p>（1）生成堆转储快照</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>The jmap command prints shared object memory maps or heap memory details of a specified process, core file, or remote debug server.</span></span></code></pre></div><blockquote><p>（2）打印出堆内存相关信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jmap -heap PID</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jinfo -flag UsePSAdaptiveSurvivorSizePolicy 35352</span></span>
<span class="line"><span>-XX:SurvivorRatio=8</span></span></code></pre></div><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/ac32aa9fcc89458eb5cac86209bdfa0a.png" alt="image.png" loading="lazy"></p><blockquote><p>（3）dump出堆内存相关信息</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jmap -dump:format=b,file=heap.hprof PID</span></span></code></pre></div><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1655274390025/837bbf874f234b6f9a2f432c31eedbc6.png" alt="image.png" loading="lazy"></p><blockquote><p>（4）要是在发生堆内存溢出的时候，能自动dump出该文件就好了</p></blockquote><p>一般在开发中，JVM参数可以加上下面两句，这样内存溢出时，会自动dump出该文件</p><p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>设置堆内存大小: -Xms20M -Xmx20M</span></span>
<span class="line"><span>启动，然后访问localhost:9090/heap，使得堆内存溢出</span></span></code></pre></div><h2 id="jvm常用参数以及垃圾收集器常见参数-一般会问你怎么调整的垃圾收集器的具体参数-上节课是泛参数" tabindex="-1">JVM常用参数以及垃圾收集器常见参数（一般会问你怎么调整的垃圾收集器的具体参数，上节课是泛参数）： <a class="header-anchor" href="#jvm常用参数以及垃圾收集器常见参数-一般会问你怎么调整的垃圾收集器的具体参数-上节课是泛参数" aria-label="Permalink to &quot;JVM常用参数以及垃圾收集器常见参数（一般会问你怎么调整的垃圾收集器的具体参数，上节课是泛参数）：&quot;">​</a></h2><h2 id="jvm调优-调整某些参数-为了让程序达到硬件性能瓶颈" tabindex="-1">JVM调优 调整某些参数 为了让程序达到硬件性能瓶颈 <a class="header-anchor" href="#jvm调优-调整某些参数-为了让程序达到硬件性能瓶颈" aria-label="Permalink to &quot;JVM调优  调整某些参数 为了让程序达到硬件性能瓶颈&quot;">​</a></h2><h3 id="gc常用参数-一般各个垃圾收集器都可以使用的一些打印类参数以及大-类似于堆内存大小这种-参数" tabindex="-1">GC常用参数（一般各个垃圾收集器都可以使用的一些打印类参数以及大（类似于堆内存大小这种）参数） <a class="header-anchor" href="#gc常用参数-一般各个垃圾收集器都可以使用的一些打印类参数以及大-类似于堆内存大小这种-参数" aria-label="Permalink to &quot;GC常用参数（一般各个垃圾收集器都可以使用的一些打印类参数以及大（类似于堆内存大小这种）参数）&quot;">​</a></h3><p>-Xmx：设置堆的最大值，一般为操作系统的 2/3 大小 MaxHeapSize</p><p>-Xms：设置堆的初始值，一般设置成和 Xmx 一样的大小来避免动态扩容。 InitialHeapSize</p><p>项目启动直接Full GC</p><p>-Xmn：表示年轻代的大小，默认新生代占堆大小的 1/3。高并发、对象快消亡场景可适当加大这个区域，对半，或者更多，都是可以的。但是在 G1 下，就不用再设置这个值了，它会自动调整。</p><p>-Xss：用于设置栈的大小，默认为 1M，如果代码中局部变量不多，可设置成256K节约空间。</p><p>-XX:+UseTLAB 使用TLAB，默认打开</p><p>-XX:+PrintTLAB 打印TLAB的使用情况</p><p>-XX:TLABSize 设置TLAB大小</p><p>-XX:+DisableExplicitGC 启用用于禁用对的调用处理的选项System.gc()</p><p>-XX:+PrintGC 查看GC基本信息</p><p>-XX:+PrintGCDetails 查看GC详细信息</p><p>-XX:+PrintHeapAtGC 每次一次GC后，都打印堆信息</p><p>-XX:+PrintGCTimeStamps 启用在每个GC上打印时间戳的功能</p><p>-XX:+PrintGCApplicationConcurrentTime 打印应用程序时间(低)</p><p>-XX:+PrintGCApplicationStoppedTime 打印暂停时长（低）</p><p>-XX:+PrintReferenceGC 记录回收了多少种不同引用类型的引用（重要性低）</p><p>-verbose:class 类加载详细过程</p><p>-XX:+PrintVMOptions 可在程序运行时，打印虚拟机接受到的命令行显示参数</p><p>-XX:+PrintFlagsFinal -XX:+PrintFlagsInitial 打印所有的JVM参数、查看所有JVM参数启动的初始值（必须会用）</p><p>-XX:MaxTenuringThreshold</p><p>升代（分代）年龄，这个值在CMS 下默认为 6，G1 下默认为 15，这个值和我们前面提到的对象提升有关，改动效果会比较明显。对象的年龄分布可以使用 -XX:+PrintTenuringDistribution 打印，如果后面几代的大小总是差不多，证明过了某个年龄后的对象总能晋升到老生代，就可以把晋升阈值设小。</p><h3 id="parallel常用参数" tabindex="-1">Parallel常用参数 <a class="header-anchor" href="#parallel常用参数" aria-label="Permalink to &quot;Parallel常用参数&quot;">​</a></h3><p><strong>-XX:SurvivorRatio 你要讲的出道理</strong></p><p>设置伊甸园空间大小与幸存者空间大小之间的比率。默认情况下，此选项设置为<strong>8</strong></p><p><strong>-XX:PreTenureSizeThreshold 对象到达一定的限定值的时候 会直接进入老年代</strong></p><p>大对象到底多大，大于这个值的参数直接在老年代分配</p><p><strong>-XX:MaxTenuringThreshold</strong></p><p>升代年龄，最大值15 <strong>并行（吞吐量）收集器的默认值为</strong>15，而CMS收集器的默认值为6。</p><p><strong>-XX:+ParallelGCThreads</strong></p><p>并行收集器的线程数，同样适用于<strong>CMS</strong>，一般设为和CPU核数相同</p><p><strong>-XX:+UseAdaptiveSizePolicy</strong></p><p>自动选择各区大小比例</p><h3 id="cms常用参数" tabindex="-1"><strong>CMS常用参数</strong> <a class="header-anchor" href="#cms常用参数" aria-label="Permalink to &quot;**CMS常用参数**&quot;">​</a></h3><p><strong>-XX:+UseConcMarkSweepGC</strong></p><p><strong>启用</strong>CMS垃圾回收器</p><p><strong>-XX:+ParallelGCThreads</strong></p><p>并行收集器的线程数，同样适用于<strong>CMS</strong>，一般设为和CPU核数相同</p><p><strong>-XX:CMSInitiatingOccupancyFraction 并发失败的模式</strong></p><p><strong>使用多少比例的老年代后开始</strong>CMS收集，默认是68%(近似值)，如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）</p><p><strong>-XX:+UseCMSCompactAtFullCollection</strong></p><p><strong>在</strong>FGC时进行压缩</p><p><strong>-XX:CMSFullGCsBeforeCompaction</strong></p><p><strong>多少次</strong>FGC之后进行压缩</p><p><strong>-XX:+CMSClassUnloadingEnabled</strong></p><p>使用并发标记扫描（<strong>CMS</strong>）垃圾收集器时，启用类卸载。默认情况下启用此选项。</p><p><strong>-XX:CMSInitiatingPermOccupancyFraction</strong></p><p><strong>达到什么比例时进行</strong>Perm Space回收，<strong>JDK 8</strong>中不推荐使用此选项，不能替代。</p><p>-XX:GCTimeRatio</p><p>设置<strong>GC</strong>时间占用程序运行时间的百分比（不推荐使用）</p><p><strong>-XX:MaxGCPauseMillis</strong></p><p>停顿时间，是一个建议时间，<strong>GC</strong>会尝试用各种手段达到这个时间，比如减小年轻代</p><h3 id="g1常用参数" tabindex="-1"><strong>G1常用参数</strong> <a class="header-anchor" href="#g1常用参数" aria-label="Permalink to &quot;**G1常用参数**&quot;">​</a></h3><p><strong>-XX:+UseG1GC</strong></p><p>启用G1垃圾收集器</p><p><strong>-XX:MaxGCPauseMillis</strong></p><p><strong>设置最大</strong>GC暂停时间的目标（以毫秒为单位）。这是一个软目标，并且JVM将尽最大的努力（G1会尝试调整Young区的块数来）来实现它。默认情况下，没有最大暂停时间值。</p><p><strong>-XX:GCPauseIntervalMillis</strong></p><p>GC的间隔时间</p><p><strong>-XX:+G1HeapRegionSize 你的堆内存小于2G的时候 4C8G起步</strong></p><p><strong>单个Region大小，取值是1M-32M，建议逐渐增大该值，<strong>1 2 4 8 16 32</strong>。随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长-XX:G1NewSizePercent</strong> <strong>新生代最小比例，默认为</strong>1/2000</p><p><strong>-XX:G1MaxNewSizePercent</strong></p><p><strong>新生代最大比例，默认为</strong>60%</p><p><strong>-XX:GCTimeRatioGC</strong></p><p>时间建议比例，<strong>G1</strong>会根据这个值调整堆空间</p><p><strong>-XX:ConcGCThreads</strong></p><p>初始标记线程数量</p><p><strong>-XX:InitiatingHeapOccupancyPercent</strong></p><p><strong>启动</strong>G1<strong>的堆空间占用比例，根据整个堆的占用而触发并发</strong>GC周期</p><h2 id="jvm自带的可视化工具有哪些" tabindex="-1">JVM自带的可视化工具有哪些： <a class="header-anchor" href="#jvm自带的可视化工具有哪些" aria-label="Permalink to &quot;JVM自带的可视化工具有哪些：&quot;">​</a></h2><p>讲解两个大家看看就好，一般建议本地调试：</p><h3 id="jconsole" tabindex="-1">jconsole <a class="header-anchor" href="#jconsole" aria-label="Permalink to &quot;jconsole&quot;">​</a></h3><p><strong>JConsole工具是JDK自带的图形化性能监控工具。并通过JConsole工具， 可以查看Java应用程序的运行概况， 监控堆信息、 元空间使用情况及类的加载情况等。</strong></p><p>JConsole程序在%JAVA_HOM E%/bin目录下</p><p>或者你可以直接在命令行对他进行打印</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/12597031b6e44327b0c12ac06244244a.png" alt="image.png" loading="lazy"></p><p>会显示如下界面：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/889f8f9b80354e588892b3eb3ae87c1c.png" alt="image.png" loading="lazy"></p><h4 id="jconsole的连接方式" tabindex="-1">JConsole的连接方式 <a class="header-anchor" href="#jconsole的连接方式" aria-label="Permalink to &quot;JConsole的连接方式&quot;">​</a></h4><p>JConsole分为本地连接以及远程连接，一般我们本地连接在小型单体项目中用于本地分析较多，大型项目以及线上生产环境一般采用远程连接的方式。</p><h5 id="本地连接" tabindex="-1">本地连接： <a class="header-anchor" href="#本地连接" aria-label="Permalink to &quot;本地连接：&quot;">​</a></h5><p>Jconsole会在本地自动寻找当前的可监控进程，所以我们可以只要本地启动项目，就可以自动匹配并点击进去。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/242f9982bf274d099b25df1c28963b90.png" alt="image.png" loading="lazy"></p><h5 id="远程连接" tabindex="-1">远程连接： <a class="header-anchor" href="#远程连接" aria-label="Permalink to &quot;远程连接：&quot;">​</a></h5><ol><li>设置被监控的Java虚拟机启动的參数，一般的情况下，会有下面三个參数，各自是：</li></ol><p>-Dcom.sun.management.jmxremote.port=1090</p><p>-Dcom.sun.management.jmxremote.ssl=false</p><p>-Dcom.sun.management.jmxremote.authenticate=false</p><p>也就是说，你需要在启动参数后面加上这几个参数</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/1c16f91a0f1246778332e8f590974262.png" alt="image.png" loading="lazy"></p><p>被监控的虚拟机启动以后，我们就能够其他电脑上通Jconsole进行远程连接。</p><p>连接的过程例如以下：</p><p>1.打开cmd，输入jconsole，就会出现jconsole控制台，</p><p>然后，我们输入要被监控的Java虚拟机的IP地址和port号，如果输入正确，连接button就上生效如果设计的监控port号为8082，连接的IP为：10.20.618.11（这个需要你防火墙以及端口都处于开放状态），例如以下图所看到的：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/b2f94d65785a4acfbc85d5535889fbab.png" alt="image.png" loading="lazy"></p><p>点击连接后，就会进入到正常的显示界面，说明就连接成功了。</p><h4 id="jconsole的显示界面" tabindex="-1">JConsole的显示界面： <a class="header-anchor" href="#jconsole的显示界面" aria-label="Permalink to &quot;JConsole的显示界面：&quot;">​</a></h4><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/4f1e3fa6d8994f3892000fc84208b20f.png" alt="image.png" loading="lazy"></p><p><strong>概述</strong> ：记录了“堆内存使用情况”、“线程”、“类”、“CPU使用情况”共四个资源的实时情况；</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/efb1b06e892f4a229ba574aad14fb713.png" alt="image.png" loading="lazy"></p><p>并且在时间范围可以选择从1分钟到1年的显示情况</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/1b9494333e5b49b5bc39053c1b3aab5a.png" alt="image.png" loading="lazy"></p><p><strong>内存</strong> ：可以选择查看“堆内存使用情况”、“非堆内存使用情况”、“内存池&quot;PS Eden Space&quot;”等内存占用的实时情况；界面右下角还有图形化的堆一级、二级、三级缓存（从左到右）占用情况，当然，如果三级缓存被全部占用也就是很可能内存溢出啦！这时可以去查看服务器的tomcat日志，应该会有“outofmemory&quot;的异常日志信息。界面右上角处还提供了一个“执行GC”的手动垃圾收集功能，这个也很实用~而且界面下方还有详细的GC信息记录。，整个界面提供了关于垃圾收集必须的各项基础指标查询。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/059844d8479d4b6895ddad61ac6bd895.png" alt="image.png" loading="lazy"></p><p><strong>线程</strong> ：界面上部显示实时线程数目。下部还能查看到详细的每个进程及相应状态、等待、堆栈追踪等信息；</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/45c682b9d11e45418add74b5f1142b7c.png" alt="image.png" loading="lazy"></p><p>并且在右下角，我们还可以检测死锁的情况。如果当前线程没有出现死锁，那么会显示未出现死锁。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/73785f956bf447cf858f15255fd211a7.png" alt="image.png" loading="lazy"></p><p>但是如果出现了死锁，这里也会进行相应的检测。会直接显示死锁的页面，并且我们可以通过点击对应的线程来查看死锁的信息。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/b6d4ddf4763f473b9e7416ad225677e6.png" alt="image.png" loading="lazy"></p><p><strong>类</strong> ：显示“已装入类的数目”、“已卸载类的数目”信息；</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/ae89012cdda545aa884e405d3e68cee2.png" alt="image.png" loading="lazy"></p><p><strong>VM摘要</strong> ：显示服务器详细资源信息，包括：线程、类、OS、内存等；</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/8e41461bfa03410cb3ad8efedfd66bfc.png" alt="image.png" loading="lazy"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1656048868088/18602db0ff9741ad8d4719359c8feaff.png" alt="image.png" loading="lazy"></p><p><strong>MBean</strong> : 可在此页进行参数的配置。</p><p><em>MBean就是被JMX管理的资源。</em> 一般有两种类型的MBean,标准的和动态的。 标准类型的MBean最简单,它能管理的资源(包括属性,方法,时间)必须定义在接口中,然后MBean必须实现这个接口。它的命名也必须遵循一定的规范,例如我们的MBean为User,则接口必须为UserMBean。 动态MBean必须实现javax.management.DynamicMBean接口,所有的属性,方法都在运行时定义。</p><p>这个一般情况下互联网交互式企业级开发用到的可能性没有那么高。因为现在JMX架构用得没那么多。</p><h4 id="测试垃圾回收案例" tabindex="-1">测试垃圾回收案例： <a class="header-anchor" href="#测试垃圾回收案例" aria-label="Permalink to &quot;测试垃圾回收案例：&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.example.jvmcase.test;</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.google.common.collect.Lists;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.ArrayList;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JconsoleTest1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //将bytes设置为全局变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] bytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //测试内存的变化情况</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//为了能看到效果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (InterruptedException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;开始..&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        fillHeap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fillHeap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ArrayList&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">JconsoleTest1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; jts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Lists.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newArrayList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count;i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                //这里睡3S，出效果</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (InterruptedException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                e.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            jts.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> JconsoleTest1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>监控JVM内存情况，发现持续不回收，内存持续上升。</p><p>接下来，将bytes放进构造函数中，变成局部变量。如果没有使用的情况下，垃圾回收器是会光顾。现在再去看内存情况，发现内存在垃圾回收时候会形成波峰。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  JconsoleTest2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //将bytes设置为局部变量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] bytes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h3 id="jvisualvm" tabindex="-1">jvisualvm <a class="header-anchor" href="#jvisualvm" aria-label="Permalink to &quot;jvisualvm&quot;">​</a></h3><p>官网：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jvisualvm.html" target="_blank" rel="noreferrer">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jvisualvm.html</a></p><p>官方描述：</p><blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Description</span></span>
<span class="line"><span>Java VisualVM is an intuitive graphical user interface that provides detailed information about Java technology-based applications (Java applications) while they are running on a specified Java Virtual Machine (JVM). The name Java VisualVM comes from the fact that Java VisualVM provides information about the JVM software visually.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Java VisualVM combines several monitoring, troubleshooting, and profiling utilities into a single tool. For example, most of the functionality offered by the standalone tools jmap, jinfo, jstat, and jstack were integrated into Java VisualVM. Other functionality, such as some that offered by the jconsole command, can be added as optional plug-ins.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Java VisualVM is useful to Java application developers to troubleshoot applications and to monitor and improve the applications&#39; performance. Java VisualVM enables developers to generate and analyze heap dumps, track down memory leaks, perform and monitor garbage collection, and perform lightweight memory and CPU profiling. You can expand the Java VisualVM functionality with plug-ins. For example, most of the functionality of the jconsole command is available through the MBeans Tab and JConsole Plug-in Wrapper plug-ins. You can choose from a catalog of standard Java VisualVM plug-ins by selecting Tools and then Plugins in the Java VisualVM menus.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Start Java VisualVM with the following command:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>%  jvisualvm &lt;options&gt;</span></span></code></pre></div></blockquote><p><strong>大致意思：</strong></p><p>Java VisualVM 是一个直观的图形用户界面，可在基于 Java 技术的应用程序（Java 应用程序）在指定的 Java 虚拟机 (JVM) 上运行时提供有关它们的详细信息。</p><p>Java VisualVM 将多个监控、故障排除和分析实用程序组合到一个工具中。例如，独立工具jmap、jinfo和提供jstat,的大部分功能jstack都集成到 Java VisualVM 中。其他功能，例如jconsole命令提供的一些功能，可以作为可选插件添加。</p><p>Java VisualVM 对于 Java 应用程序开发人员对应用程序进行故障排除以及监控和改进应用程序的性能非常有用。Java VisualVM 使开发人员能够生成和分析堆转储、跟踪内存泄漏、执行和监视垃圾收集以及执行轻量级内存和 CPU 分析。</p><p>使用以下命令启动 Java VisualVM：</p><p>% jvisualvm &lt;选项&gt;</p><h4 id="监控本地java进程" tabindex="-1">监控本地Java进程 <a class="header-anchor" href="#监控本地java进程" aria-label="Permalink to &quot;监控本地Java进程&quot;">​</a></h4><p>可以监控本地的java进程的CPU，类，线程等</p><h4 id="监控远端java进程" tabindex="-1">监控远端Java进程 <a class="header-anchor" href="#监控远端java进程" aria-label="Permalink to &quot;监控远端Java进程&quot;">​</a></h4><p>（1）在visualvm中选中“远程”，右击“添加”</p><p>（2）主机名上写服务器的ip地址，比如39.100.39.63，然后点击“确定”</p><p>（3）右击该主机&quot;39.100.39.63&quot;，添加“JMX”，也就是通过JMX技术具体监控远端服务器哪个Java进程</p><p>（4）要想让服务器上的tomcat被连接，需要改一下Catalina.sh这个文件</p><blockquote><p><strong>注意下面的8998不要和服务器上其他端口冲突</strong></p></blockquote><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">JAVA_OPTS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$JAVA_OPTS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> -Dcom.sun.management.jmxremote -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Djava.rmi.server.hostname=39.100.39.63 -Dcom.sun.management.jmxremote.port=8998</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">-Dcom.sun.management.jmxremote.ssl=false -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Dcom.sun.management.jmxremote.authenticate=true -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access -</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password&quot;</span></span></code></pre></div><p>（5）在../conf文件中添加两个文件jmxremote.access和jmxremote.password</p><p><strong>jmxremote.access</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>guest readonly</span></span>
<span class="line"><span>manager readwrite</span></span></code></pre></div><p><strong>jmxremote.password</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>guest guest</span></span>
<span class="line"><span>manager manager</span></span></code></pre></div><p>授予权限：chmod 600 <em>jmxremot</em></p><p>（6）将连接服务器地址改为公网ip地址</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hostname</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   查看输出情况</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	172.26.225.240</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 172.17.0.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/hosts</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	172.26.255.240</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 39.100.39.63</span></span></code></pre></div><p>（7）设置上述端口对应的阿里云安全策略和防火墙策略</p><p>（8）启动tomcat，来到bin目录</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>./startup.sh</span></span></code></pre></div><p>（9）查看tomcat启动日志以及端口监听</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>tail -f ../logs/catalina.out</span></span>
<span class="line"><span>lsof -i tcp:8080</span></span></code></pre></div><p>（10）查看8998监听情况，可以发现多开了几个端口</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lsof</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -i:8998</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    得到PID</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">netstat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -antup</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> grep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> PID</span></span></code></pre></div><p>（11）在刚才的JMX中输入8998端口，并且输入用户名和密码则登录成功</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>端口:8998</span></span>
<span class="line"><span>用户名:manager</span></span>
<span class="line"><span>密码:manager</span></span></code></pre></div><h2 id="亿级流量电商系统jvm调优" tabindex="-1"><strong>亿级流量电商系统JVM调优</strong> <a class="header-anchor" href="#亿级流量电商系统jvm调优" aria-label="Permalink to &quot;**亿级流量电商系统JVM调优**&quot;">​</a></h2><h3 id="亿级流量系统" tabindex="-1"><strong>亿级流量系统</strong> <a class="header-anchor" href="#亿级流量系统" aria-label="Permalink to &quot;**亿级流量系统**&quot;">​</a></h3><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/050e154e614f4cccb4b8e4799a16a960.png" alt="image.png" loading="lazy"></p><p>亿级流量系统，其实就是每天点击量在亿级的系统，根据淘宝的一个官方的数据分析。</p><p>每个用户一次浏览点击20~40次之间，推测出每日活跃用户（日活用户）在500万左右。</p><p>同时结合淘宝的一个点击数据，可以发现，能够付费的也就是橙色的部分（cart）的用户，比例只有10%左右。</p><p>90%的用户仅仅是浏览，那么我们可以通过图片缓存、Redis缓存等技术，我们可以把90%的用户解决掉。</p><p>10%的付费用户，大概算出来是每日成交50万单左右。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/c5d531e3725d44b4b35ae45b97fbbc7d.png" alt="image.png" loading="lazy"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/2510d2a18cf8484cbc3d6b241af31655.png" alt="image.png" loading="lazy"></p><h4 id="gc预估" tabindex="-1"><strong>GC</strong>预估 <a class="header-anchor" href="#gc预估" aria-label="Permalink to &quot;**GC**预估&quot;">​</a></h4><p>如果是普通业务，一般处理时间比较平缓，大概在3,4个小时处理，算出来每秒只有几十单，这个一般的应用可以处理过来（不需要JVM预估调优）</p><p>另外电商系统中有大促场景（秒杀、限时抢购等），一般这种业务是几种在几分钟。我们算出来大约每秒2000单左右的数据，</p><p>承受大促场景的使用4台服务器（使用负载均衡）。每台订单服务器也就是大概500单/秒</p><p>我们测试发现，每个订单处理过程中会占据0.2MB大小的空间（什么订单信息、优惠券、支付信息等等），那么一台服务器每秒产生100M的内存空间，这些对象基本上都是朝生夕死，也就是1秒后都会变成垃圾对象。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/b51677ca2c9049858c6bf371adbe0e69.png" alt="image.png" loading="lazy"></p><p>加入我们设置堆的空间最大值为3个G，我们按照默认情况下的设置，新生代1/3的堆空间，老年代2/3的堆空间。Eden:S0:S1=8:1:1</p><p>我们推测出，old区=2G,Eden区=800M,S0=S1=100M</p><p>根据对象的分配原则（对象优先在Eden区进行分配），由此可得，8秒左右Eden区空间满了。</p><p>每8秒触发一个MinorGC（新生代垃圾回收），这次MinorGC时，JVM要STW，但是这个时候有100M的对象是不能回收的（线程暂停，对象需要1秒后都会变成垃圾对象），那么就会有100M的对象在本次不能被回收（只有下次才能被回收掉）</p><p>所以经过本次垃圾回收后。本次存活的100M对象会进入S0区，但是由于另外一个JVM对象分配原则（如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄）</p><p>所以这样的对象本质上不会进去Survivor区，而是进入老年代</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/c7759e1487324ad7a3cd469a609a5144.png" alt="image.png" loading="lazy"></p><p>所以我们推算，大概每个8秒会有100M的对象进入老年代。大概20*8=160秒，也就是2分40秒左右old区就会满掉，就会触发一次FullGC,一般来说，这次FullGC是可以避免的，同时由于FullGC不单单回收老年代+新生代，还要回收元空间，这些FullGC的时间可能会比较长（老年代回收的朝生夕死的对象，使用标记清除/标记整理算法决定了效率并不高,同时元空间也要回收一次，进一步加大GC时间）。</p><p>所以问题的根本就是做到如何避免没有必要的FullGC</p><h4 id="gc预估调优" tabindex="-1"><strong>GC<strong><strong>预估</strong></strong>调优</strong> <a class="header-anchor" href="#gc预估调优" aria-label="Permalink to &quot;**GC****预估****调优**&quot;">​</a></h4><p>我们在项目中加入VM参数：</p><p>-Xms3072M -Xmx3072M -Xmn2048M -XX:SurvivorRatio=7</p><p>-Xss256K -XX:MetaspaceSize= 128M -XX:MaxMetaspaceSize= 128M</p><p>-XX:MaxTenuringThreshold=2</p><p>-XX:ParallelGCThreads=8</p><p>-XX:+UseConcMarkSweepGC</p><p>1、首先看一下堆空间：old区=1G，Eden区=1.4G,S0=S1=300M</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/b3010e87b1814d05845d49c3b7af6dc5.png" alt="image.png" loading="lazy"></p><p>1、那么第一点，Eden区大概需要14秒才能填满，填满之后，100M的存活对象会进入S0区（由于这个区域变大，不会触发动态年龄判断）</p><p>2、再过14秒，Eden区，填满之后，还是剩余100M的对象要进入S1区。但是由于原来的100M已经是垃圾了（过了14秒了），所以，S1也只会有Eden区过来的100M对象，S0的100M已经别回收，也不会触发动态年龄判断。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/c12626a0a380470da8c7361ace99ad37.png" alt="image.png" loading="lazy"></p><p>3、反反复复，这样就没有对象会进入old区，就不会触发FullGC,同时我们的MinorGC的频次也由之前的8秒变为14秒，虽然空间加大，但是换来的还是GC的总时间会减少。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/2e9743a5944c4ed9a238f1bb4a77609b.png" alt="image.png" loading="lazy"></p><p>4、-Xss256K -XX:MetaspaceSize= 128M -XX:MaxMetaspaceSize= 128M 栈一般情况下很少用到1M。所以为了线程占用内存更少，我们可以减少到256K</p><p>元空间一般启动后就不会有太多的变化，我们可以设定为128M，节约内存空间。</p><p>5、-XX:MaxTenuringThreshold=2 这个是分代年龄（年龄为2就可以进入老年代），因为我们基本上都使用的是Spring架构，Spring中很多的bean是长期要存活的，没有必要在Survivor区过渡太久，所以可以设定为2，让大部分的Spring的内部的一些对象进入老年代。</p><p>6、-XX:ParallelGCThreads=8 线程数可以根据你的服务器资源情况来设定（要速度快的话可以设置大点，根据CPU的情况来定，一般设置成CPU的整数倍）</p><p>7、-XX:+UseConcMarkSweepGC 因为这个业务响应时间优先的，所以还是可以使用CMS垃圾回收器或者G1垃圾回收器。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/1022aa7273f44f6d82ae1246f8c49492.png" alt="image.png" loading="lazy"></p><p>8、-XX:+UseConcMarkSweepGC 因为这个业务响应时间优先的，所以还是可以使用CMS垃圾回收器或者G1垃圾回收器。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/773b2ce945544dfb8eb5d2111c35024f.png" alt="image.png" loading="lazy"></p><p>案例2：电商场景大致的估算</p><h3 id="内存分配" tabindex="-1">内存分配 <a class="header-anchor" href="#内存分配" aria-label="Permalink to &quot;内存分配&quot;">​</a></h3><blockquote><p>正常情况下不需要设置，那如果是促销或者秒杀的场景呢？</p><p>每台机器配置2c4G，以每秒3000笔订单为例，整个过程持续60秒</p></blockquote><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/0bea66dd6f8540ce8b60851865fbb00c.png" alt="image.png" loading="lazy"></p><h3 id="_4-1-2-内存溢出-oom" tabindex="-1">4.1.2 内存溢出(OOM) <a class="header-anchor" href="#_4-1-2-内存溢出-oom" aria-label="Permalink to &quot;4.1.2 内存溢出(OOM)&quot;">​</a></h3><blockquote><p>一般会有两个原因：</p><p>（1）大并发情况下</p><p>（2）内存泄露导致内存溢出</p></blockquote><h4 id="_4-1-2-1-大并发-秒杀" tabindex="-1">4.1.2.1 大并发[秒杀] <a class="header-anchor" href="#_4-1-2-1-大并发-秒杀" aria-label="Permalink to &quot;4.1.2.1 大并发[秒杀]&quot;">​</a></h4><p>浏览器缓存、本地缓存、验证码</p><p>CDN静态资源服务器</p><p>集群+负载均衡</p><p>动静态资源分离、限流[基于令牌桶、漏桶算法]</p><p>应用级别缓存、接口防刷限流、队列、Tomcat性能优化</p><p>异步消息中间件</p><p>Redis热点数据对象缓存</p><p>分布式锁、数据库锁</p><p>5分钟之内没有支付，取消订单、恢复库存等</p><h4 id="内存泄露导致内存溢出" tabindex="-1">内存泄露导致内存溢出 <a class="header-anchor" href="#内存泄露导致内存溢出" aria-label="Permalink to &quot;内存泄露导致内存溢出&quot;">​</a></h4><blockquote><p>ThreadLocal引起的内存泄露，最终导致内存溢出</p><div class="language-Java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TLController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;/tl&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HttpServletRequest </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     ThreadLocal&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]&gt; tl </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThreadLocal&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]&gt;();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 1MB</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     tl.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Byte</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ok&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></blockquote><p>（1）上传到阿里云服务器</p><p>jvm-case-0.0.1-SNAPSHOT.jar</p><p>（2）启动</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>java -jar -Xms1000M -Xmx1000M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=jvm.hprof  jvm-case-0.0.1-SNAPSHOT.jar</span></span></code></pre></div><p>（3）使用jmeter模拟10000次并发</p><p>39.100.39.63:8080/tl</p><p>（4）top命令查看</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>top</span></span>
<span class="line"><span>top -Hp PID</span></span></code></pre></div><p>（5）jstack查看线程情况，发现没有死锁或者IO阻塞的情况</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jstack PID</span></span>
<span class="line"><span>java -jar arthas.jar   ---&gt;   thread</span></span></code></pre></div><p>（6）查看堆内存的使用，发现堆内存的使用率已经高达88.95%</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jmap -heap PID</span></span>
<span class="line"><span>java -jar arthas.jar   ---&gt;   dashboard</span></span></code></pre></div><p>（7）此时可以大体判断出来，发生了内存泄露从而导致的内存溢出，那怎么排查呢？</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>jmap -histo:live PID | more</span></span>
<span class="line"><span>获取到jvm.hprof文件，上传到指定的工具分析，比如heaphero.io</span></span></code></pre></div><h2 id="jvm性能优化指南" tabindex="-1">JVM性能优化指南 <a class="header-anchor" href="#jvm性能优化指南" aria-label="Permalink to &quot;JVM性能优化指南&quot;">​</a></h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1463/1693753462070/ac681c129e8a4208a976a2b027a736f3.png" alt="image.png" loading="lazy"></p><h2 id="常见问题分析" tabindex="-1"><strong>常见问题分析</strong> <a class="header-anchor" href="#常见问题分析" aria-label="Permalink to &quot;**常见问题分析**&quot;">​</a></h2><h3 id="超大对象" tabindex="-1"><strong>超大对象</strong> <a class="header-anchor" href="#超大对象" aria-label="Permalink to &quot;**超大对象**&quot;">​</a></h3><p>代码中创建了很多大对象 , 且一直因为被引用不能被回收，这些大对象会进入老年代，导致内存一直被占用，很容易引发GC甚至是OOM</p><h3 id="超过预期访问量" tabindex="-1"><strong>超过预期访问量</strong> <a class="header-anchor" href="#超过预期访问量" aria-label="Permalink to &quot;**超过预期访问量**&quot;">​</a></h3><p>通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。</p><p>比如如果一个系统高峰期的内存需求需要2个G的堆空间，但是堆空间设置比较小，导致内存不够，导致JVM发起频繁的GC甚至OOM。</p><h3 id="过多使用finalizer" tabindex="-1"><strong>过多使用Finalizer</strong> <a class="header-anchor" href="#过多使用finalizer" aria-label="Permalink to &quot;**过多使用Finalizer**&quot;">​</a></h3><p>过度使用终结器（Finalizer），对象没有立即被 GC，Finalizer线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐，程序消耗了所有的可用资源，最后抛出OutOfMemoryError异常。</p><h3 id="内存泄漏" tabindex="-1"><strong>内存泄漏</strong> <a class="header-anchor" href="#内存泄漏" aria-label="Permalink to &quot;**内存泄漏**&quot;">​</a></h3><p>大量对象引用没有释放，JVM 无法对其自动回收。</p><h4 id="长生命周期的对象持有短生命周期对象的引用" tabindex="-1"><strong>长生命周期的对象持有短生命周期对象的引用</strong> <a class="header-anchor" href="#长生命周期的对象持有短生命周期对象的引用" aria-label="Permalink to &quot;**长生命周期的对象持有短生命周期对象的引用**&quot;">​</a></h4><p>例如将ArrayList设置为静态变量，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏</p><h4 id="连接未关闭" tabindex="-1"><strong>连接未关闭</strong> <a class="header-anchor" href="#连接未关闭" aria-label="Permalink to &quot;**连接未关闭**&quot;">​</a></h4><p>如数据库连接、网络连接和IO连接等，只有连接被关闭后，垃圾回收器才会回收对应的对象。</p><h4 id="变量作用域不合理" tabindex="-1"><strong>变量作用域不合理</strong> <a class="header-anchor" href="#变量作用域不合理" aria-label="Permalink to &quot;**变量作用域不合理**&quot;">​</a></h4><p>例如，1.一个变量的定义的作用范围大于其使用范围，2.如果没有及时地把对象设置为null</p><h4 id="内部类持有外部类" tabindex="-1"><strong>内部类持有外部类</strong> <a class="header-anchor" href="#内部类持有外部类" aria-label="Permalink to &quot;**内部类持有外部类**&quot;">​</a></h4><p>Java的非静态内部类的这种创建方式，会隐式地持有外部类的引用，而且默认情况下这个引用是强引用，因此，如果内部类的生命周期长于外部类的生命周期，程序很容易就产生内存泄漏</p><p>如果内部类的生命周期长于外部类的生命周期，程序很容易就产生内存泄漏（垃圾回收器会回收掉外部类的实例，但由于内部类持有外部类的引用，导致垃圾回收器不能正常工作）</p><p>解决方法：你可以在内部类的内部显示持有一个外部类的软引用(或弱引用)，并通过构造方法的方式传递进来，在内部类的使用过程中，先判断一下外部类是否被回收；</p><h4 id="hash值改变" tabindex="-1"><strong>Hash值改变</strong> <a class="header-anchor" href="#hash值改变" aria-label="Permalink to &quot;**Hash值改变**&quot;">​</a></h4><p>在集合中，如果修改了对象中的那些参与计算哈希值的字段，会导致无法从集合中单独删除当前对象，造成内存泄露</p><p>预估系统配置的十个方法，前面已经举了两个案例。</p>`,320),e=[t];function l(h,o,k,r,c,g){return i(),a("div",null,e)}const E=s(p,[["render",l]]);export{y as __pageData,E as default};

import{_ as a,c as e,o,a4 as t}from"./chunks/framework.rIDq68an.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.01-Java/JUC/锁.md","filePath":"01-Dev/01.01-Java/JUC/锁.md"}'),r={name:"01-Dev/01.01-Java/JUC/锁.md"},n=t('<h2 id="synchronized-可重入锁" tabindex="-1">Synchronized 可重入锁 <a class="header-anchor" href="#synchronized-可重入锁" aria-label="Permalink to &quot;Synchronized 可重入锁&quot;">​</a></h2><p>因为他是关键字, 所以必须满足可重入锁, 不然 子类去调用父类方法的时候 是实现不了的</p><h3 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to &quot;实现原理&quot;">​</a></h3><p>在方法和代码块上添加 sync 关键字, javac 编译的时候会在字节码文件中生成 <code>monitorenter</code> 和 <code>monitorexit</code> 分别代表着 sync 的进入同步代码块和退出同步代码块, 此时 <code>monitorexit</code> 会生成两个, 是因为 Javac 隐式的生成了一个 try finally, 目的是为了保证在程序发生异常时也会<strong>解锁</strong></p><h2 id="reentrantlock-可重入锁" tabindex="-1">ReentrantLock 可重入锁 <a class="header-anchor" href="#reentrantlock-可重入锁" aria-label="Permalink to &quot;ReentrantLock 可重入锁&quot;">​</a></h2><h2 id="semaphore" tabindex="-1">Semaphore <a class="header-anchor" href="#semaphore" aria-label="Permalink to &quot;Semaphore&quot;">​</a></h2><h2 id="countdownlatch" tabindex="-1">countDownLatch <a class="header-anchor" href="#countdownlatch" aria-label="Permalink to &quot;countDownLatch&quot;">​</a></h2><h2 id="readwritelock" tabindex="-1">readWriteLock <a class="header-anchor" href="#readwritelock" aria-label="Permalink to &quot;readWriteLock&quot;">​</a></h2><h2 id="locksupport" tabindex="-1">LockSupport <a class="header-anchor" href="#locksupport" aria-label="Permalink to &quot;LockSupport&quot;">​</a></h2>',9),c=[n];function i(h,d,l,s,_,p){return o(),e("div",null,c)}const k=a(r,[["render",i]]);export{m as __pageData,k as default};

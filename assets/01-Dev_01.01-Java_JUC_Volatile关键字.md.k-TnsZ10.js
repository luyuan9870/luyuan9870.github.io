import{_ as e,c as a,o as l,a4 as o}from"./chunks/framework.BG61BEI0.js";const P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.01-Java/JUC/Volatile关键字.md","filePath":"01-Dev/01.01-Java/JUC/Volatile关键字.md"}'),t={name:"01-Dev/01.01-Java/JUC/Volatile关键字.md"},i=o('<h2 id="前置知识" tabindex="-1">前置知识 <a class="header-anchor" href="#前置知识" aria-label="Permalink to &quot;前置知识&quot;">​</a></h2><p>CPU多级缓存架构 JMM内存模型 MESI协议 本质上是使用了CPU的 高速缓存一致性协议 缓存一致性协议 需要了解</p><h2 id="能干嘛" tabindex="-1">能干嘛 <a class="header-anchor" href="#能干嘛" aria-label="Permalink to &quot;能干嘛&quot;">​</a></h2><ol><li>保证多线程之间的数据可见性 2. 堆内存是所有线程共享里面的内存,除了共享的内存之外呢, 每个线程都有自己的专属的区域, 都有自己的工作内存,如果说在共享内存里有一个值的话, 当我们某一个线程都要去访问这个值的时候,就会将这个值Copy一份到自己的工作空间里, 然后对这个值的任何改变, 首先是在自己的空间进行改变, 什么时候歇会去, 就是改完之后会马上歇会去, 什么时候去检查有没有新的值 也不好控制 3. 在这个县城里发生的改变,并没有及时的反映到另外一个线程里面, 这就是线程之间的不可见, 对这个变量值增加了volatile之后就能保证一个线程的改变,另一个线程马上就能看到</li><li>禁止指令重排序(CPU) <ol><li>DCL单例</li><li>DoubleCheckLock (二次检查锁) <ol><li>LoadFence 源语指令</li><li>StoreFence 源语指令 解释一下什么是指令重排序 以及为什么要禁止指令重排序</li></ol></li><li>CPU为了提升效率, 他把指令 并发的来执行,第一个指令执行到一半的时候 第二个指令可能就已经开始工作了,这叫流水线式的执行,在这种新的架构设计基础之上,想充分的利用这一点, 那么就要求你的编译器把你的源码编译完的指令 进行一个 指令的重新排序</li></ol></li></ol><p>详解重排序 重排序有三种类型 内存重排序: CPU 中的 L1/L2/L3 级高速缓冲区读取的字节数据, 可能会导致看起来是乱序执行的 指令重排序 : CPU 指令可以多条并行, 不存在数据依赖的情况下会进行指令的重排 编译重排序 : 编译器在不改变单线程语义的情况下, 可以进行指令的重排</p>',5),r=[i];function _(c,n,s,d,h,p){return l(),a("div",null,r)}const m=e(t,[["render",_]]);export{P as __pageData,m as default};

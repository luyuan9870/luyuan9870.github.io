import{_ as e,c as a,o as t,a4 as l}from"./chunks/framework.BG61BEI0.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.01-Java/JUC/线程池.md","filePath":"01-Dev/01.01-Java/JUC/线程池.md","lastUpdated":1713951737000}'),i={name:"01-Dev/01.01-Java/JUC/线程池.md"},r=l('<h2 id="什么是池化技术" tabindex="-1">什么是池化技术 <a class="header-anchor" href="#什么是池化技术" aria-label="Permalink to &quot;什么是池化技术&quot;">​</a></h2><p>核心思想是资源的复用, 把多个线程都放进池子里面去管理, 用的时候直接从池子里取, 不用的时候在放回池子. 从而规避掉线程创建和销毁的性能开销.</p><h2 id="线程池的七大参数" tabindex="-1">线程池的七大参数 <a class="header-anchor" href="#线程池的七大参数" aria-label="Permalink to &quot;线程池的七大参数&quot;">​</a></h2><ol><li><p>核心线程数： 可以理解成最小核心线程数， 就是 长期存活的线程有多少个</p></li><li><p>最大线程数： 线程池允许的最大线程数，当线程池的队列满了之后可以创建最大线程，最大线程数量不包含核心线程数量</p></li><li><p>空闲线程存活时间： 当没有任务执行的时候，空闲线程存活多久之后会进行线程销毁的操作</p></li><li><p>时间单位： 空闲线程的存活时间单位</p></li><li><p>线程队列： 阻塞队列，线程池存放待执行任务的队列。</p></li><li><p>线程工厂： 创建线程的工厂类</p></li><li><p>拒绝策略： 当线程池的任务超出了任务队列可以存储的最大值以后，执行的策略。默认有四种策略</p></li><li><p>默认策略： 拒绝并抛出异常</p></li><li><p>使用当前线程来执行任务</p></li><li><p>抛弃队列头节点的任务，并执行当前任务</p></li><li><p>忽略并抛弃当前任务</p></li></ol><hr><p>参考 <a href="https://riemann.blog.csdn.net/article/details/104704197?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5-104704197-blog-129107342.235%5Ev40%5Epc_relevant_3m_sort_dl_base1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-5-104704197-blog-129107342.235%5Ev40%5Epc_relevant_3m_sort_dl_base1&amp;utm_relevant_index=10" target="_blank" rel="noreferrer">线程池中各个参数如何合理设置_线程池配置参数数值如何确定-CSDN博客</a></p>',6),_=[r];function p(o,n,s,d,c,m){return t(),a("div",null,_)}const v=e(i,[["render",p]]);export{u as __pageData,v as default};

import{_ as i,c as e,o as t,a4 as l}from"./chunks/framework.BG61BEI0.js";const R=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.08-数据库/03-Redis/深入理解Redis/6.Redis-面试.md","filePath":"01-Dev/01.08-数据库/03-Redis/深入理解Redis/6.Redis-面试.md"}'),s={name:"01-Dev/01.08-数据库/03-Redis/深入理解Redis/6.Redis-面试.md"},o=l("<p><strong>Redis 如何保证数据一致性的问题?</strong></p><ol><li>先更新数据库，在更新缓存。（先读数据库，数据库中没有再去读缓存，写的时候先写数据库，再将数据库的数据写入到缓存）。缓存可能会更新失败，读取到老的数据从而产生数据不一致问题</li><li>先删除缓存，在更新数据库。当并发量高的时候，数据库的写操作可能还没有来得及提交数据，此时另外一个线程读取到数据还是会产生（）就是先操作数据库还是先操作缓存的问题延迟双删的方案先删除缓存，在去更新数据库，然后休眠多少毫秒（这个需要程序员去预估）在删除缓存这样等下次请求进来的时候缓存中没有数据，就会读取数据库并重新写入缓存</li></ol><ul><li>先更新数据库, 在去更新缓存 <ul><li><strong>问题：</strong> 更新数据库之后，还没有更新缓存之前。数据是会有不一致的情况发生</li></ul></li><li>先更新缓存，在更新数据库 <ul><li><strong>问题：</strong> 在多线程环境下，A 线程修改了缓存去改数据库的途中， B 线程再次修改了缓存。还是会有不一致问题</li></ul></li><li>先删除缓存，在更新数据库 <ul><li><strong>问题：</strong> 在读写并发的情况下，还是会有不一致的问题</li></ul></li><li>先更新数据库，在删除缓存 <strong>（推荐）</strong><ul><li><blockquote><p>缓存的写入速度，相对比数据库的写入速度要快。</p></blockquote></li><li><strong>问题：</strong> 在删除缓存的途中，这一个时间间隙还是存在不一致。</li><li>不管是哪一种解决方案都 <strong>不可能存在实时的一致性。</strong> 如果一定要保证实时性，那么建议不要去使用 Redis 缓存。</li></ul></li></ul>",3),r=[o];function n(_,d,a,c,u,g){return t(),e("div",null,r)}const m=i(s,[["render",n]]);export{R as __pageData,m as default};

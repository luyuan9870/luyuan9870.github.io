import{_ as a,c as e,o as t,a4 as o}from"./chunks/framework.BG61BEI0.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.01-Java/JVM/00-前言.md","filePath":"01-Dev/01.01-Java/JVM/00-前言.md"}'),r={name:"01-Dev/01.01-Java/JVM/00-前言.md"},l=o('<p>什么方法可以改善代码性能 会原理是因为这个原理会帮助 在生产环境 进行调优/排错的</p><p>常规的内容要学的仔细, 才能有足够的知识进行性能优化</p><h2 id="jvm到底帮我们做了什么事情" tabindex="-1">JVM到底帮我们做了什么事情? <a class="header-anchor" href="#jvm到底帮我们做了什么事情" aria-label="Permalink to &quot;JVM到底帮我们做了什么事情?&quot;">​</a></h2><p>Java语言之所以可以跨平台, 全部都是基于JVM来做的, JVM的作用</p><ul><li>屏蔽底层硬件和操作系统的差异</li><li>把Java代码(人类看得懂的高级语言) 转变成字节码(JVM语言) 由JVM转换成二进制的机器码,给底层的系统去看</li></ul><h3 id="编译原理" tabindex="-1">编译原理 <a class="header-anchor" href="#编译原理" aria-label="Permalink to &quot;编译原理&quot;">​</a></h3><blockquote><p>切割 当前的Java文件, 解析里面的语法 是否属于Java语法, 生成树的结构 去存储 当前内容 语法树</p></blockquote><p>字节码生成器 去生成Class</p><h3 id="javac-命令是做了什么事情" tabindex="-1">javac 命令是做了什么事情 <a class="header-anchor" href="#javac-命令是做了什么事情" aria-label="Permalink to &quot;javac 命令是做了什么事情&quot;">​</a></h3><p>把Java文件编译成字节码文件 class 也就是把高级语言的特性, 转换成JVM能够读懂的语言 也就是根据JVM所制定的一系列规范,读取Java文件的内容, 生成出JVM所需要的内容 举个栗子 我在Map中定义了一系列 KV 比如 此时 Key 就是 Java语言的语法, Value 就是对应的 JVM所能看懂的内容, 我遍历完这一个Map 最终的结果, 就是jvm完全能够看得懂的class字节码文件</p><h3 id="常量池里存了什么东西" tabindex="-1">常量池里存了什么东西 <a class="header-anchor" href="#常量池里存了什么东西" aria-label="Permalink to &quot;常量池里存了什么东西&quot;">​</a></h3><p>字面量 文本 final修饰的内容. 符号引用 引用 类名,方法名,字段名,接口 把Class文件当成一个模板, 去加载到常量池中 索引从1开始 到consPoolCount -1</p><h3 id="调优" tabindex="-1">调优 <a class="header-anchor" href="#调优" aria-label="Permalink to &quot;调优&quot;">​</a></h3><p>调优 有很多维度, 有时候并不一定要去设置 JVM的参数 代码维度 机器维度 JVM 一定是最后最后 才去选择 修改参数的. 当然 <strong>堆栈内存除外</strong>, 这个东西 他不会去自适应服务器的配置而去动态变更</p>',14),s=[l];function c(i,n,h,_,p,d){return t(),e("div",null,s)}const u=a(r,[["render",c]]);export{v as __pageData,u as default};

import{_ as l,c as a,o as i,a4 as e}from"./chunks/framework.BG61BEI0.js";const t="/assets/Pastedimage20231022104523.Y1LhhQTC.png",p="/assets/Pastedimage20231022105646.DlZd08fM.png",M=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.01-Java/JVM/02-运行时数据区.md","filePath":"01-Dev/01.01-Java/JVM/02-运行时数据区.md","lastUpdated":1712823825000}'),s={name:"01-Dev/01.01-Java/JVM/02-运行时数据区.md"},_=e('<p>JVM 是一个抽象的物理机, 是遵循了冯诺依曼的计算机模型结构的</p><p>类加载之后的 运行时数据区</p><h2 id="堆内存的布局" tabindex="-1">堆内存的布局 <a class="header-anchor" href="#堆内存的布局" aria-label="Permalink to &quot;堆内存的布局&quot;">​</a></h2><p><img src="'+t+'" alt="Pastedimage20231022104523.png" loading="lazy"></p><p>方法区: (逻辑上 是属于 堆内存的一部分, 也有人管方法区叫做非堆内存)</p><ol><li>方法是线程共享的, 方法区在JVM启动的时候创建 (跟JVM的进程进行绑定 可以理解成JVM的守护进程)</li><li>存储 类的结构信息/常量池/字段和方法的元数据/还有一些结构方法</li><li>如果内存不够用, JVM会抛出OOM 元数据区</li></ol><p>堆内存 (和方法区 基本一致, 只是存储的东西不一致) 堆内存也是线程共享的, 堆内存也是JVM启动的时候创建的. 存储的是 对象实例以及数组 内存不够也会抛出OOM <img src="'+p+'" alt="Pastedimage20231022105646.png" loading="lazy"></p><blockquote><p>方法区+堆 = JVM运行时数据区的主存</p></blockquote><p>线程想获取CPU的执行权, 抢占CPU的时间片 (由CPU分配的 CPU内部的线程调度机制)</p><p>============== 线程私有的================</p><p>栈内存 特点: 先进后出 压栈帧(子弹上膛) Java虚拟机栈 本地方法栈 栈溢出异常</p><p>程序计数器 用来CPU调度到当前线程时, 记录执行到哪里 从哪里继续执行的东西</p><p>对象头实例数据的对其填充 CPU 取数据取的是16KB数据,</p><p>堆内存以外 是堆内存布局</p><p>JVM的内存布局清楚了, 能聊的有什么呢?</p><ul><li>当前执行的方法是Native的, 那么Java虚拟机栈 是怎么调用的本地方法栈? <ul><li>动态链接 <ul><li>为了支持方法调用过程中, 动态的调用过程.</li><li>动态链接 是为了 把 符号方法引用转换成直接方法引用</li><li>符号引用转换成直接引用. (类的加载机制时 有类似的功能)</li><li>A调用B调用C调用D的链路</li></ul></li><li>每个方法的调用, 都是一个栈帧 <ul><li>每一个栈帧都有的操作 (栈帧信息) <ul><li>局部变量表 <ul><li>存放局部变量,方法的内容 变量</li></ul></li><li>操作数栈</li><li>动态链接</li><li>返回地址</li><li>附加信息</li></ul></li></ul></li></ul></li></ul><p>内存逃逸分析 没有内存逃逸则进行栈上分配</p>',17),o=[_];function n(r,c,d,u,m,J){return i(),a("div",null,o)}const V=l(s,[["render",n]]);export{M as __pageData,V as default};

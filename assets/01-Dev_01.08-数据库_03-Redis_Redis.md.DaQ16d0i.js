import{_ as i,c as l,o as p,a4 as e}from"./chunks/framework.rIDq68an.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.08-数据库/03-Redis/Redis.md","filePath":"01-Dev/01.08-数据库/03-Redis/Redis.md"}'),s={name:"01-Dev/01.08-数据库/03-Redis/Redis.md"},d=e("<ol><li>Redis 快的原理 <ol><li>优雅的数据结构 <ol><li>动态字符串</li><li>双端链表</li><li>压缩列表</li><li>跳表</li></ol></li><li>单线程的存取模型,没有上下文切换</li><li>IO的多路复用</li></ol></li></ol><ul><li><p>Redis 存储数据的细节问题</p></li><li><p>缓存穿透、缓存击穿、缓存雪崩都是什么，并且怎么解决</p></li><li><p>穿透： 原因是缓存和数据库中都没有的数据，可能会给缓存/数据库带来一些性能压力，可以采用缓存一个短时效性的默认值来防止数据库的访问压力，当数据库被写入或者更新该key的数据时，缓存必须同时刷新来避免数据库不一致的问题</p></li><li><p>击穿： 原因是热点数据失效，导致大量的请求落到了数据库上可能会给数据库带来一些性能压力，可以通过设置key永不过期，然后在后台更新缓存</p></li><li><p>雪崩：原因是大量的缓存数据同一时间全部失效或者Redis 宕机，这个可以设置不通的过期时间来解决该问题</p></li><li><p>Redis 的热点key问题如何解决</p></li><li><p>可以设置永不过期， 然后由子线程或者MQ等技术来实现更新热点数据的操作。</p></li><li><p>Redis的应用场景，存放哪些数据，有哪些特点</p></li><li><p>缓存一些数据，计数器、分布式锁、全局ID、标签、数据字典</p></li><li><p>redis天生就是原子性，每一个操作都是原子性的，对数据的更改要么全部成功，要么全部失败</p></li><li><p>redis 有事务支持</p></li><li><p>Redis的数据类型，Redis 是单线程还是多线程</p></li><li><p>Redis是多线程的，严格意义上说， 它的网络IO和数据读写是单线程的，但是像数据持久化，异步删除等操作还是由其他线程来执行的</p></li><li><p>Redis如何保证数据一致性问题1) 先更新数据库，在更新缓存。（先读数据库，数据库中没有再去读缓存，写的时候先写数据库，再将数据库的数据写入到缓存）。缓存可能会更新失败，读取到老的数据从而产生数据不一致问题2） 先删除缓存，在更新数据库。当并发量高的时候，数据库的写操作可能还没有来得及提交数据，此时另外一个线程读取到数据还是会产生（）就是先操作数据库还是先操作缓存的问题延迟双删的方案先删除缓存，在去更新数据库，然后休眠多少毫秒（这个需要程序员去预估）在删除缓存这样等下次请求进来的时候 缓存中没有数据，就会读取数据库并重新写入缓存</p></li><li><p>Redis 实现分布式锁</p></li></ul><p>采用SetNx命令， 这个命令可以判断当前key是否存在，如果存在就获取锁， 如果不存在就获取不到锁。</p><p>采用Lua脚本可以实现 多命令的原子性操作。</p><p>考虑到锁过期问题，还需要启动一个子线程来定时监听锁是否需要续期</p><p>原理就是通过setnx来抢占锁，之后再给当前锁加入过期时间来防止死锁</p><ul><li><p>Redis的持久化操作</p></li><li><p>RDB 快照数据, 比较快, 但是容易丢失数据.不是很安全.</p></li><li><p>在指定的间隔时间内，将Redis内存中的所有数据进行一个快照备份写入到磁盘文件中</p></li><li><p>快照完成之后会产生一个 dump.rdb文件，方便持久化</p></li><li><p>容灾性好，方便备份</p></li><li><p>相对于数据量大的情况下，比AOF的启动效率要高。</p></li><li><p>对于大规模的数据恢复 对数据的完整性要求不高的情况下。恢复数据的速度特别快</p></li><li><p>AOF AOF是 记录命令.安全 但是比较慢</p></li><li><p>以日志的形式来记录每一次Redis 操作的命令（不包含查询），</p></li><li><p>Redis 对AOF提供了三种同步策略，每秒同步，每个命令同步和不同步三种</p></li><li><p>采用Append追加模式，数据安全</p></li></ul>",7),t=[d];function o(_,a,R,r,n,c){return p(),l("div",null,t)}const f=i(s,[["render",o]]);export{m as __pageData,f as default};

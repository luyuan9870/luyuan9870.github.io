import{_ as t,c as a,o as e,a4 as d}from"./chunks/framework.BG61BEI0.js";const _=JSON.parse('{"title":"时间复杂度、对数器、二分法与异或运算","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.05-算法/02-导读.md","filePath":"01-Dev/01.05-算法/02-导读.md"}'),r={name:"01-Dev/01.05-算法/02-导读.md"},l=d('<h1 id="时间复杂度、对数器、二分法与异或运算" tabindex="-1">时间复杂度、对数器、二分法与异或运算 <a class="header-anchor" href="#时间复杂度、对数器、二分法与异或运算" aria-label="Permalink to &quot;时间复杂度、对数器、二分法与异或运算&quot;">​</a></h1><p>常数时间的操作、固定时间的操作</p><blockquote><p>算术运算, 位与运算,、自增、自检、比较、 寻址（偏移量）得到当前值， 数组的寻址操作</p></blockquote><p>时间复杂度： 只关心量级，</p><p>异或运算 异或运算:相同为0,不同为1 同或运算:相同为1,不同为0</p><p>+1 为什么是或运算?</p><blockquote><p>左移 == 乘2</p></blockquote><p>程序设计=数据结构+算法</p><h1 id="什么是算法" tabindex="-1">什么是算法 <a class="header-anchor" href="#什么是算法" aria-label="Permalink to &quot;什么是算法&quot;">​</a></h1><blockquote><p>巧妇难为无米之炊, <code> 巧妇 == 算法. 数据结构 == 米</code></p></blockquote><ul><li><p>根据具体的问题，设计解决问题的具体流程。</p></li><li><p>根据一定的条件， 对一些数据进行计算，得到需要对结果 （可以解决具体的问题）</p></li><li><p>有设计解决的具体流程 （高斯算法）</p></li><li><p>花费最少的时间完成需求，占据最少内的存完成需求被称之为优质的算法 （有评价这个算法的具体指标=时间空间复杂度）</p></li><li><p>时间复杂度</p></li><li><p>空间复杂度</p></li></ul><h1 id="位运算" tabindex="-1">位运算 <a class="header-anchor" href="#位运算" aria-label="Permalink to &quot;位运算&quot;">​</a></h1><p>逻辑位运算</p><p>位移位运算</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>＆ 位与</td><td>如果相对应位都是1，则结果为1，否则为0</td><td>（A＆B），得到12，即0000 1100</td></tr><tr><td>| 位或</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A | B）得到61，即 0011 1101</td></tr><tr><td>^ 异或</td><td>如果相对应位值相同，则结果为0，否则为1</td><td>（A ^ B）得到49，即 0011 0001</td></tr><tr><td>〜 取反</td><td>按位取反运算符翻转操作数的每一位，即0变成1，1变成0。</td><td>（〜A）得到-61，即1100 0011</td></tr><tr><td>&lt;&lt; 左移</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。<br><br>简单理解成 左移几位就相乘了几</td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td>&gt;&gt; 右移</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A &gt;&gt; 2得到15即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><p><strong><code>^</code> 异或 == 无进位相加</strong></p><blockquote><p>异或运算就记成无进位相加 : 二进制的相加 同样的一批数异或得到的结果值一定是一样的 0^n == n n^n == 0 // 解释: 二进制的无进位相加</p></blockquote><p>异或运算 A ^ b 满足交换率和结合率 <strong>前提: 同一块内存 ^ 运算会变成 0</strong></p><p>位与运算 A &amp; A 取反+1 的结果 =</p><h2 id="位图" tabindex="-1">位图 <a class="header-anchor" href="#位图" aria-label="Permalink to &quot;位图&quot;">​</a></h2><p>压缩空间，</p><p>一个int 占4个byte 一个byte占4bit，</p><h1 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h1><h2 id="可达性分析" tabindex="-1">可达性分析： <a class="header-anchor" href="#可达性分析" aria-label="Permalink to &quot;可达性分析：&quot;">​</a></h2><p>理解成树结构-》 找子树或者叶子结点 都能够找得到</p><p>Java</p><ul><li>值传递</li><li>不会认内存地址， 就看自面值</li><li>和引用传递</li><li>会认内存地址</li></ul><p>因为java只有一种传递参数的方式：值传递。 在值传递中，实参的值被传给形参，方法体内对形参的任何赋值操作都不会影响到实参。 对形参的任何赋值操作都不会影响到实参，但是对于形参的字段，或者元素（假如形参是一个数组）的赋值操作会影响实参。 <img src="https://cdn.nlark.com/yuque/0/2022/png/22905513/1667958162042-3040d305-759d-43cb-ab70-94cb20ab8b98.png" alt="" loading="lazy"> map在put 的时候， key 如果是基本类型+string类型， 默认是按照字面值， 如果是自己定义的对象， 是按照引用查找 引用传递 在map中只会存在引用地址， 值传递 对于原方法是不可见的 引用传递对于原方法是可见的（A方法定义了一个 obj 传递给B方法， B方法对Obj做了修改是可见的）</p><h2 id="二进制" tabindex="-1">二进制 <a class="header-anchor" href="#二进制" aria-label="Permalink to &quot;二进制&quot;">​</a></h2><p>计算机中表示负数: 正数的二进制 -1, 取反</p><p>参考</p><ul><li><a href="https://www.yuque.com/fcant/ds/ffmip0" target="_blank" rel="noreferrer">Fcant-数据结构大总结</a></li></ul>',32),o=[l];function p(i,n,c,h,s,b){return e(),a("div",null,o)}const q=t(r,[["render",p]]);export{_ as __pageData,q as default};

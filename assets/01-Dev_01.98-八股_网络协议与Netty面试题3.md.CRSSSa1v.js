import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.BG61BEI0.js";const c=JSON.parse('{"title":"1、讲一讲什么是零拷贝？","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.98-八股/网络协议与Netty面试题3.md","filePath":"01-Dev/01.98-八股/网络协议与Netty面试题3.md","lastUpdated":1712833290000}'),t={name:"01-Dev/01.98-八股/网络协议与Netty面试题3.md"},p=n(`<h1 id="_1、讲一讲什么是零拷贝" tabindex="-1">1、讲一讲什么是零拷贝？ <a class="header-anchor" href="#_1、讲一讲什么是零拷贝" aria-label="Permalink to &quot;1、讲一讲什么是零拷贝？&quot;">​</a></h1><h2 id="零拷贝" tabindex="-1"><strong>零拷贝</strong> <a class="header-anchor" href="#零拷贝" aria-label="Permalink to &quot;**零拷贝**&quot;">​</a></h2><h3 id="什么是零拷贝" tabindex="-1"><strong>什么是零拷贝?</strong> <a class="header-anchor" href="#什么是零拷贝" aria-label="Permalink to &quot;**什么是零拷贝?**&quot;">​</a></h3><p>零拷贝(英语: Zero-copy) 技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。</p><p>➢零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率</p><p>➢零拷贝技术减少了用户进程地址空间和内核地址空间之间因为上:下文切换而带来的开销</p><p>可以看出没有说不需要拷贝，只是说减少冗余[不必要]的拷贝。</p><p>下面这些组件、框架中均使用了零拷贝技术：Kafka、Netty、Rocketmq、Nginx、Apache。</p><h3 id="linux的i-o机制与dma" tabindex="-1"><strong>Linux的I/O机制与DMA</strong> <a class="header-anchor" href="#linux的i-o机制与dma" aria-label="Permalink to &quot;**Linux的I/O机制与DMA**&quot;">​</a></h3><p>在早期计算机中，用户进程需要读取磁盘数据，需要CPU中断和CPU参与，因此效率比较低，发起IO请求，每次的IO中断，都带来CPU的上下文切换。因此出现了——DMA。</p><p>DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于CPU 的大量中断负载。</p><p>DMA控制器，接管了数据读写请求，减少CPU的负担。这样一来，CPU能高效工作了。现代硬盘基本都支持DMA。</p><p>实际因此IO读取，涉及两个过程：</p><p>1、DMA等待数据准备好，把磁盘数据读取到操作系统内核缓冲区；</p><p>2、用户进程，将内核缓冲区的数据copy到用户空间。</p><p>这两个过程，都是阻塞的。</p><h3 id="传统数据传送机制" tabindex="-1"><strong>传统数据传送机制</strong> <a class="header-anchor" href="#传统数据传送机制" aria-label="Permalink to &quot;**传统数据传送机制**&quot;">​</a></h3><p>比如：读取文件，再用socket发送出去，实际经过四次copy。</p><p>伪码实现如下：</p><p>buffer = File.read()</p><p>Socket.send(buffer)</p><p>1、第一次：将磁盘文件，读取到操作系统内核缓冲区；</p><p>2、第二次：将内核缓冲区的数据，copy到应用程序的buffer；</p><p>3、第三步：将application应用程序buffer中的数据，copy到socket网络发送缓冲区(属于操作系统内核的缓冲区)；</p><p>4、第四次：将socket buffer的数据，copy到网卡，由网卡进行网络传输。</p><p>![](file:///C:\\Users\\lijin\\AppData\\Local\\Temp\\ksohtml3176\\wps1.jpg)<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1697108505063/5e72ee364b434bc9ad9cbd9705eacb98.png" alt="image.png" loading="lazy"></p><p>分析上述的过程，虽然引入DMA来接管CPU的中断请求，但四次copy是存在“不必要的拷贝”的。实际上并不需要第二个和第三个数据副本。应用程序除了缓存数据并将其传输回套接字缓冲区之外什么都不做。相反，数据可以直接从读缓冲区传输到套接字缓冲区。</p><p>显然，第二次和第三次数据copy 其实在这种场景下没有什么帮助反而带来开销，这也正是零拷贝出现的背景和意义。</p><p>同时，read和send都属于系统调用，每次调用都牵涉到两次上下文切换：</p><p>![](file:///C:\\Users\\lijin\\AppData\\Local\\Temp\\ksohtml3176\\wps2.jpg)<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1697108505063/616b95b498384af093d4808fd70de920.png" alt="image.png" loading="lazy"></p><p>总结下，传统的数据传送所消耗的成本：4次拷贝，4次上下文切换。</p><p>4次拷贝，其中两次是DMA copy，两次是CPU copy。</p><h3 id="linux支持的-常见-零拷贝" tabindex="-1"><strong>Linux支持的(常见)零拷贝</strong> <a class="header-anchor" href="#linux支持的-常见-零拷贝" aria-label="Permalink to &quot;**Linux支持的(常见)零拷贝**&quot;">​</a></h3><p>目的：减少IO流程中不必要的拷贝，当然零拷贝需要OS支持，也就是需要kernel暴露api。</p><h4 id="mmap内存映射" tabindex="-1"><em><strong>mmap内存映射</strong></em> <a class="header-anchor" href="#mmap内存映射" aria-label="Permalink to &quot;***mmap内存映射***&quot;">​</a></h4><p>硬盘上文件的位置和应用程序缓冲区(application buffers)进行映射（建立一种一一对应关系），由于mmap()将文件直接映射到用户空间，所以实际文件读取时根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝，不再有文件内容从硬盘拷贝到内核空间的一个缓冲区。</p><p>mmap内存映射将会经历：3次拷贝: 1次cpu copy，2次DMA copy；</p><p>以及4次上下文切换</p><p>![](file:///C:\\Users\\lijin\\AppData\\Local\\Temp\\ksohtml3176\\wps3.jpg)<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1697108505063/26d9c19af4604dc6b0e6a97631b799cc.png" alt="image.png" loading="lazy"></p><h4 id="sendfile" tabindex="-1"><em><strong>sendfile</strong></em> <a class="header-anchor" href="#sendfile" aria-label="Permalink to &quot;***sendfile***&quot;">​</a></h4><p>linux 2.1支持的sendfile</p><p>当调用sendfile()时，DMA将磁盘数据复制到kernel buffer，然后将内核中的kernel buffer直接拷贝到socket buffer。在硬件支持的情况下，甚至数据都并不需要被真正复制到socket关联的缓冲区内。取而代之的是，只有记录数据位置和长度的描述符被加入到socket缓冲区中，DMA模块将数据直接从内核缓冲区传递给协议引擎，从而消除了遗留的最后一次复制。</p><p>一旦数据全都拷贝到socket buffer，sendfile()系统调用将会return、代表数据转化的完成。socket buffer里的数据就能在网络传输了。</p><p>sendfile会经历：3次拷贝，1次CPU copy ，2次DMA copy；硬件支持的情况下，则是2次拷贝，0次CPU copy， 2次DMA copy。</p><p>以及2次上下文切换</p><p>![](file:///C:\\Users\\lijin\\AppData\\Local\\Temp\\ksohtml3176\\wps4.jpg)<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1697108505063/bd0704c9f56f4eff8521f013b85fcb69.png" alt="image.png" loading="lazy"></p><h4 id="splice" tabindex="-1"><em><strong>splice</strong></em> <a class="header-anchor" href="#splice" aria-label="Permalink to &quot;***splice***&quot;">​</a></h4><p>Linux 从2.6.17 支持splice</p><p>数据从磁盘读取到OS内核缓冲区后，在内核缓冲区直接可将其转成内核空间其他数据buffer，而不需要拷贝到用户空间。</p><p>如下图所示，从磁盘读取到内核buffer后，在内核空间直接与socket buffer建立pipe管道。</p><p>和sendfile()不同的是，splice()不需要硬件支持。</p><p>注意splice和sendfile的不同，sendfile是将磁盘数据加载到kernel buffer后，需要一次CPU copy，拷贝到socket buffer。而splice是更进一步，连这个CPU copy也不需要了，直接将两个内核空间的buffer进行pipe。</p><p>splice会经历 2次拷贝: 0次cpu copy 2次DMA copy；</p><p>以及2次上下文切换</p><p>![](file:///C:\\Users\\lijin\\AppData\\Local\\Temp\\ksohtml3176\\wps5.jpg)<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1697108505063/f03b8a6277504b5dae651f87b1e65262.png" alt="image.png" loading="lazy"></p><h4 id="总结linux中零拷贝" tabindex="-1"><em><strong>总结L</strong></em><em><strong>inux</strong></em><em><strong>中零拷贝</strong></em> <a class="header-anchor" href="#总结linux中零拷贝" aria-label="Permalink to &quot;***总结L******inux******中零拷贝***&quot;">​</a></h4><p>最早的零拷贝定义，来源于</p><p><em>Linux 2.4内核新增 sendfile 系统调用，提供了零拷贝。磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NI<strong>O</strong> Buffer(socket buffer)，无需 CPU 拷贝。这也是零拷贝这一说法的来源。这是真正操作系统 意义上的零拷贝(也就是狭义零拷贝)。</em></p><p>但是我们知道，由OS内核提供的 操作系统意义上的零拷贝，发展到目前也并没有很多种，也就是这样的零拷贝并不是很多；</p><p>随着发展，零拷贝的概念得到了延伸，就是目前的减少不必要的数据拷贝都算作零拷贝的范畴。</p><h3 id="java生态圈中的零拷贝" tabindex="-1"><strong>Java生态圈中的零拷贝</strong> <a class="header-anchor" href="#java生态圈中的零拷贝" aria-label="Permalink to &quot;**Java生态圈中的零拷贝**&quot;">​</a></h3><p>Linux提供的零拷贝技术 Java并不是全支持，支持2种(内存映射mmap、sendfile)；</p><h4 id="nio提供的内存映射-mappedbytebuffer" tabindex="-1"><em><strong>NIO提供的内存映射 MappedByteBuffer</strong></em> <a class="header-anchor" href="#nio提供的内存映射-mappedbytebuffer" aria-label="Permalink to &quot;***NIO提供的内存映射 MappedByteBuffer***&quot;">​</a></h4><p>NIO中的FileChannel.map()方法其实就是采用了操作系统中的内存映射方式，底层就是调用Linux mmap()实现的。</p><p>将内核缓冲区的内存和用户缓冲区的内存做了一个地址映射。这种方式适合读取大文件，同时也能对文件内容进行更改，但是如果其后要通过SocketChannel发送，还是需要CPU进行数据的拷贝。</p><h4 id="nio提供的sendfile" tabindex="-1"><em><strong>NIO提供的sendfile</strong></em> <a class="header-anchor" href="#nio提供的sendfile" aria-label="Permalink to &quot;***NIO提供的sendfile***&quot;">​</a></h4><p>Java NIO 中提供的 FileChannel 拥有 transferTo 和 transferFrom 两个方法，可直接把 FileChannel 中的数据拷贝到另外一个 Channel，或者直接把另外一个 Channel 中的数据拷贝到 FileChannel。该接口常被用于高效的网络 / 文件的数据传输和大文件拷贝。在操作系统支持的情况下，通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换，也即使用了“零拷贝”，所以其性能一般高于 Java IO 中提供的方法。</p><h4 id="kafka中的零拷贝" tabindex="-1"><em><strong>Kafka中的零拷贝</strong></em> <a class="header-anchor" href="#kafka中的零拷贝" aria-label="Permalink to &quot;***Kafka中的零拷贝***&quot;">​</a></h4><p>Kafka两个重要过程都使用了零拷贝技术，且都是操作系统层面的狭义零拷贝，一是Producer生产的数据存到broker，二是 Consumer从broker读取数据。</p><p>Producer生产的数据持久化到broker，采用mmap文件映射，实现顺序的快速写入；</p><p>Customer从broker读取数据，采用sendfile，将磁盘文件读到OS内核缓冲区后，直接转到socket buffer进行网络发送。</p><h4 id="netty的零拷贝实现" tabindex="-1"><em><strong>Netty的零拷贝实现</strong></em> <a class="header-anchor" href="#netty的零拷贝实现" aria-label="Permalink to &quot;***Netty的零拷贝实现***&quot;">​</a></h4><p>Netty 的零拷贝主要包含三个方面：</p><p>在网络通信上，Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p><p>在缓存操作上，Netty提供了CompositeByteBuf类，它可以将多个ByteBuf合并为一个逻辑上的ByteBuf，避免了各个ByteBuf之间的拷贝。</p><p>通过wrap操作，我们可以将byte[]数组、ByteBuf、 ByteBuffer 等包装成一个 Netty ByteBuf对象，进而避免了拷贝操作。</p><p>ByteBuf支持slice 操作，因此可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf，避免了内存的拷贝。</p><h1 id="_2、如何让单机下netty支持百万长连接" tabindex="-1">2、如何让单机下Netty支持百万长连接？ <a class="header-anchor" href="#_2、如何让单机下netty支持百万长连接" aria-label="Permalink to &quot;2、如何让单机下Netty支持百万长连接？&quot;">​</a></h1><h3 id="操作系统" tabindex="-1">操作系统 <a class="header-anchor" href="#操作系统" aria-label="Permalink to &quot;操作系统&quot;">​</a></h3><p>首先就是要突破操作系统的限制。 在Linux平台上，无论编写客户端程序还是服务端程序，在进行高并发TCP连接处理时，最高的并发数量都要受到系统对用户单一进程同时可打开文件数量的限制（这是因为系统为每个TCP连接都要创建一个socket句柄，每个socket句柄同时也是一个文件句柄）。 可使用ulimit命令查看系统允许当前用户进程打开的文件数限制：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ ulimit -n 1024</span></span></code></pre></div><p>这表示当前用户的每个进程最多允许同时打开1024个文件，这1024个文件中还得除去每个进程必然打开的标准输入，标准输出，标准错误，服务器监听 socket,进程间通讯的unix域socket等文件，那么剩下的可用于客户端socket连接的文件数就只有大概1024-10=1014个左右。也就是说缺省情况下，基于Linux的通讯程序最多允许同时1014个TCP并发连接。 对于想支持更高数量的TCP并发连接的通讯处理程序，就必须修改Linux对当前用户的进程同时打开的文件数量。 修改单个进程打开最大文件数限制的最简单的办法就是使用ulimit命令：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>$ ulimit –n 1000000</span></span></code></pre></div><h3 id="netty调优" tabindex="-1">Netty调优 <a class="header-anchor" href="#netty调优" aria-label="Permalink to &quot;Netty调优&quot;">​</a></h3><p>设置合理的线程数 对于线程池的调优,主要集中在用于接收海量设备TCP连接、TLS握手的 Acceptor线程池( Netty通常叫 boss NioEventLoop Group)上,以及用于处理网络数据读写、心跳发送的1O工作线程池(Nety通常叫 work Nio EventLoop Group)上。 对于Nety服务端,通常只需要启动一个监听端口用于端侧设备接入即可,但是如果服务端集群实例比较少,甚至是单机(或者双机冷备)部署,在端侧设备在短时间内大量接入时,需要对服务端的监听方式和线程模型做优化,以满足短时间内(例如30s)百万级的端侧设备接入的需要。 服务端可以监听多个端口,利用主从 Reactor线程模型做接入优化,前端通过SLB做4层门7层负载均衡。 主从 Reactor线程模型特点如下:服务端用于接收客户端连接的不再是一个单独的NO线程,而是一个独立的NIO线程池; Acceptor接收到客户端TCP连接请求并处理后(可能包含接入认证等),将新创建的 Socketchanne注册到I/O线程池(subReactor线程池)的某个IO线程,由它负责 Socketchannel的读写和编解码工作; Acceptor线程池仅用于客户端的登录、握手和安全认证等,一旦链路建立成功,就将链路注册到后端 sub reactor线程池的IO线程,由IO线程负责后续的IO操作。 对于IO工作线程池的优化,可以先采用系统默认值(即CPU内核数×2)进行性能测试,在性能测试过程中采集IO线程的CPU占用大小,看是否存在瓶颈， 具体可以观察线程堆栈，如果连续采集几次进行对比,发现线程堆栈都停留在 Selectorlmpl. lockAndDoSelect，则说明IO线程比较空闲,无须对工作线程数做调整。 如果发现IO线程的热点停留在读或者写操作,或者停留在 Channelhandler的执行处,则可以通过适当调大 Nio EventLoop线程的个数来提升网络的读写性能。</p><h3 id="心跳优化" tabindex="-1">心跳优化 <a class="header-anchor" href="#心跳优化" aria-label="Permalink to &quot;心跳优化&quot;">​</a></h3><p><strong>针对海量设备接入的服务端,心跳优化策略如下。</strong> (1)要能够及时检测失效的连接,并将其剔除,防止无效的连接句柄积压,导致OOM等问题 (2)设置合理的心跳周期,防止心跳定时任务积压,造成频繁的老年代GC(新生代和老年代都有导致STW的GC,不过耗时差异较大),导致应用暂停 (3)使用Nety提供的链路空闲检测机制,不要自己创建定时任务线程池,加重系统的负担,以及增加潜在的并发安全问题。 当设备突然掉电、连接被防火墙挡住、长时间GC或者通信线程发生非预期异常时,会导致链路不可用且不易被及时发现。特别是如果异常发生在凌晨业务低谷期间,当早晨业务高峰期到来时,由于链路不可用会导致瞬间大批量业务失败或者超时,这将对系统的可靠性产生重大的威胁。 从技术层面看,要解决链路的可靠性问题,必须周期性地对链路进行有效性检测。目前最流行和通用的做法就是心跳检测。</p><p><strong>心跳检测机制分为三个层面：</strong> (1)TCP层的心跳检测,即TCP的 Keep-Alive机制,它的作用域是整个TCP协议栈。 (2)协议层的心跳检测,主要存在于长连接协议中,例如MQTT。 (3)应用层的心跳检测,它主要由各业务产品通过约定方式定时给对方发送心跳消息实现。 心跳检测的目的就是确认当前链路是否可用,对方是否活着并且能够正常接收和发送消息。作为高可靠的NIO框架,Nety也提供了心跳检测机制。 <strong>一般的心跳检测策略如下。</strong> (1)连续N次心跳检测都没有收到对方的Pong应答消息或者Ping请求消息,则认为链路已经发生逻辑失效,这被称为心跳超时。 (2)在读取和发送心跳消息的时候如果直接发生了IO异常,说明链路已经失效,这被称为心跳失败。无论发生心跳超时还是心跳失败,都需要关闭链路,由客户端发起重连操作,保证链路能够恢复正常。 Nety提供了三种链路空闲检测机制,利用该机制可以轻松地实现心跳检测 (1)读空闲,链路持续时间T没有读取到任何消息。 (2)写空闲,链路持续时间T没有发送任何消息 (3)读写空闲,链路持续时间T没有接收或者发送任何消息 对于百万级的服务器，一般不建议很长的心跳周期和超时时长。 <strong>接收和发送缓冲区调优</strong> 在一些场景下,端侧设备会周期性地上报数据和发送心跳,单个链路的消息收发量并不大,针对此类场景,可以通过调小TCP的接收和发送缓冲区来降低单个TCP连接的资源占用率 当然对于不同的应用场景,收发缓冲区的最优值可能不同,用户需要根据实际场景,结合性能测试数据进行针对性的调优</p><h3 id="jvm层面相关性能优化" tabindex="-1">JVM层面相关性能优化 <a class="header-anchor" href="#jvm层面相关性能优化" aria-label="Permalink to &quot;JVM层面相关性能优化&quot;">​</a></h3><p>当客户端的并发连接数达到数十万或者数百万时,系统一个较小的抖动就会导致很严重的后果,例如服务端的GC,导致应用暂停(STW)的GC持续几秒,就会导致海量的客户端设备掉线或者消息积压,一旦系统恢复,会有海量的设备接入或者海量的数据发送很可能瞬间就把服务端冲垮。 JVM层面的调优主要涉及GC参数优化,GC参数设置不当会导致频繁GC,甚至OOM异常,对服务端的稳定运行产生重大影响。 <strong>1.确定GC优化目标</strong> GC(垃圾收集)有三个主要指标。 (1)吞吐量:是评价GC能力的重要指标,在不考虑GC引起的停顿时间或内存消耗时,吞吐量是GC能支撑应用程序达到的最高性能指标。 (2)延迟:GC能力的最重要指标之一,是由于GC引起的停顿时间,优化目标是缩短延迟时间或完全消除停顿(STW),避免应用程序在运行过程中发生抖动。 (3)内存占用:GC正常时占用的内存量。 JVM GC调优的三个基本原则如下。 (1) Minor go回收原则:每次新生代GC回收尽可能多的内存,减少应用程序发生Full gc的频率。 2)GC内存最大化原则:垃圾收集器能够使用的内存越大,垃圾收集效率越高,应用程序运行也越流畅。但是过大的内存一次 Full go耗时可能较长,如果能够有效避免FullGC,就需要做精细化调优。 (3)3选2原则:吞吐量、延迟和内存占用不能兼得,无法同时做到吞吐量和暂停时间都最优,需要根据业务场景做选择。对于大多数应用,吞吐量优先,其次是延迟。当然对于时延敏感型的业务,需要调整次序。 <strong>2.确定服务端内存占用</strong> 在优化GC之前,需要确定应用程序的内存占用大小,以便为应用程序设置合适的内存,提升GC效率。内存占用与活跃数据有关,活跃数据指的是应用程序稳定运行时长时间存活的Java对象。活跃数据的计算方式:通过GC日志采集GC数据,获取应用程序稳定时老年代占用的Java堆大小,以及永久代(元数据区)占用的Java堆大小,两者之和就是活跃数据的内存占用大小。 <strong>3.GC优化过程</strong> 1、GC数据的采集和研读 2、设置合适的JVM堆大小 3、选择合适的垃圾回收器和回收策略</p><h1 id="_3、讲一讲c10k问题和c10m问题-以及java中如何解决" tabindex="-1">3、讲一讲C10K问题和C10M问题？以及Java中如何解决？ <a class="header-anchor" href="#_3、讲一讲c10k问题和c10m问题-以及java中如何解决" aria-label="Permalink to &quot;3、讲一讲C10K问题和C10M问题？以及Java中如何解决？&quot;">​</a></h1><p>随着互联网的发展，尤其是移动互联网时代的到来，服务端对高并发的要求越来越高，也就是我们需要高性能的网络服务器。</p><p>以 C10K 为代表，需要单机同时支持 1 万个并发连接，到现在互联网要求的单机要支持 1 千万并发连接 (C10M 问题。我们分析一下：</p><p>在Java中，基本我们说的线程（Thread）实际上应该叫作“用户线程”，而对应到操作系统，还有另外一种线程叫作“内核线程”。</p><p>用户线程和内核线程之间存在一对一的关系。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1695804256019/1c856e8637454130ad31f305c192e0dd.png" alt="image.png" loading="lazy"></p><p>如果靠这种方式解决C10K或者C10M的问题有很大的问题:</p><p>1、创建成百上千个线程会导致过多的线程创建和上下文切换</p><p>2、过多的线程创建会导致栈空间占用非常大</p><p>在 JVM 中，缺省会为每个线程分配 1MB 的内存，1万个线程理论上需要消耗10 GB 的内存，1000万个线程理论上需要消耗10 TB 的内存。理论上讲服务器也没有这个资源。</p><h1 id="_2、jdk21中虚拟线程的使用" tabindex="-1">2、JDK21中虚拟线程的使用 <a class="header-anchor" href="#_2、jdk21中虚拟线程的使用" aria-label="Permalink to &quot;2、JDK21中虚拟线程的使用&quot;">​</a></h1><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.mashibing.jdk21;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.concurrent.ExecutorService;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.concurrent.Executors;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.concurrent.ThreadFactory;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VirtualThreadTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        CustomThread customThread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CustomThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">startVirtualThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(customThread);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //1、创建直接启动</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ofVirtual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(customThread);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //2、创建不启动</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread unStarted </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ofVirtual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unstarted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(customThread);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        unStarted.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//启动</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //3、使用ThreadFactory创建(标识虚拟线程名)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ThreadFactory factory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ofVirtual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;order-&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">factory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Thread thread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> factory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(customThread);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //4、使用Executors.newVirtualThreadPerTaskExecutor()创建</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ExecutorService executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newVirtualThreadPerTaskExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(customThread);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //5、使用Executors.newThreadPerTaskExecutor()结合ThreadFactory创建</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ExecutorService executor2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newThreadPerTaskExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(factory);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        executor2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(customThread);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CustomThread</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;CustomThread run&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>虚拟线程的官方介绍：<a href="https://openjdk.org/jeps/444" target="_blank" rel="noreferrer">https://openjdk.org/jeps/444</a></p><p>1、虚拟线程对于Java开发人员来说，它只是创建成本低廉且几乎无限丰富的线程。硬件利用率接近最佳，允许高水平的并发性，因此具有高吞吐量。</p><p>测试对比案例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.mashibing.jdk21;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.lang.management.ManagementFactory;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.lang.management.ThreadInfo;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.lang.management.ThreadMXBean;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.ArrayList;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.List;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.concurrent.ExecutorService;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.concurrent.Executors;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.concurrent.ScheduledExecutorService;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.concurrent.TimeUnit;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VirtualConTest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 开启线程 统计平台线程数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ScheduledExecutorService scheduledExecutorService </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newScheduledThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        scheduledExecutorService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scheduleAtFixedRate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ThreadMXBean threadBean </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ManagementFactory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getThreadMXBean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            ThreadInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] threadInfo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> threadBean.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dumpAllThreads</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            updateMaxThreadNum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(threadInfo.length);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TimeUnit.MILLISECONDS);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 使用虚拟线程</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //ExecutorService executor =  Executors.newVirtualThreadPerTaskExecutor();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 使用平台线程</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ExecutorService executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newFixedThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // 线程睡眠 0.5 s，模拟业务处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    TimeUnit.MILLISECONDS.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (InterruptedException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ignored</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        executor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;max：&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot; platform thread/os thread&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;totalMillis：%dms</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, System.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">currentTimeMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> start);</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 更新创建的平台最大线程数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> updateMaxThreadNum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Integer integer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> integer) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, num);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>使用虚拟线程运行的时间：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1695804256019/cb7210f0a4c44d97816069cf28733ef7.png" alt="image.png" loading="lazy"></p><p>使用平台线程运行的时间：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1695804256019/8eb5fddc97d340e6be734c8f9e8718e1.png" alt="image.png" loading="lazy"></p><p>明显可以看到虚拟线程的有较高的吞吐量。</p><h1 id="_3、什么是上下文切换" tabindex="-1">3、什么是上下文切换？ <a class="header-anchor" href="#_3、什么是上下文切换" aria-label="Permalink to &quot;3、什么是上下文切换？&quot;">​</a></h1><p>在并发程序中，并不是启动更多的线程就能让程序最大限度地并发执行</p><ol><li>线程数量设置太小，会导致程序不能充分地利用系统资源</li><li>线程数量设置 <strong>太大</strong> ，可能带来资源的 <strong>过度竞争</strong> ，导致 <strong>上下文切换</strong> ，带来的额外的<strong>系统开销</strong></li></ol><p>为什么呢？</p><p>目前主流的X86 CPU是采用时间片轮转调度算法来进行任务调度的。时间片轮转调度算法是一种典型的抢占式调度算法，它将CPU的执行时间划分成若干个时间片，每个时间片的长度一般为几十毫秒到几百毫秒不等。当一个进程获得CPU后，它可以执行一个时间片的时间，然后被强制剥夺CPU，让其他进程有机会执行。这样可以保证每个进程都能获得一定的CPU时间，从而实现公平调度。</p><p>当一个线程的时间片用完，或者因自身原因被迫暂停运行，此时另一个线程会被操作系统选中来占用处理器。</p><ul><li><strong>上下文切换</strong> （Context Switch）：一个线程被<strong>暂停剥夺</strong>使用权，另一个线程被<strong>选中开始</strong>或者<strong>继续运行</strong>的过程</li><li><strong>切出</strong> ：一个线程被剥夺处理器的使用权而被暂停运行</li><li><strong>切入</strong> ：一个线程被选中占用处理器开始运行或者继续运行</li><li>切出切入的过程中，操作系统需要保存和恢复相应的 <strong>进度信息</strong> ，这个进度信息就是<em><strong>上下文</strong></em></li></ul><h2 id="_3-1、什么是-cpu-上下文" tabindex="-1">3.1、什么是 CPU 上下文？ <a class="header-anchor" href="#_3-1、什么是-cpu-上下文" aria-label="Permalink to &quot;3.1、什么是 CPU 上下文？&quot;">​</a></h2><p>其实和spring上下文差不多，CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何</p><p>任务前，必须的依赖环境。</p><ul><li><strong>寄存器的存储内容</strong> ：CPU寄存器负责存储已经、正在和将要执行的任务</li><li><strong>程序计数器存储的指令内容</strong> ：程序计数器负责存储CPU正在执行的指令位置、即将执行的下一条指令的位置</li></ul><h2 id="_3-2、什么是-cpu-上下文切换" tabindex="-1">3.2、什么是 CPU 上下文切换 <a class="header-anchor" href="#_3-2、什么是-cpu-上下文切换" aria-label="Permalink to &quot;3.2、什么是 CPU 上下文切换&quot;">​</a></h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1695804256019/5275902c66ff4619b888a050c0d102d0.png" alt="image.png" loading="lazy"></p><p>所以上下文切换的原因：</p><ul><li>自发性上下文切换</li><li><em><strong>sleep、wait、yield、join、park、synchronized、lock</strong></em></li><li>非自发性上下文切换</li><li>线程被分配的 <strong>时间片用完</strong> 、 <strong>JVM垃圾回收</strong> （ <strong>STW</strong> 、线程暂停）、线程<strong>执行优先级</strong></li></ul><h1 id="_4、jdk21中虚拟线程实现原理" tabindex="-1">4、JDK21中虚拟线程实现原理 <a class="header-anchor" href="#_4、jdk21中虚拟线程实现原理" aria-label="Permalink to &quot;4、JDK21中虚拟线程实现原理&quot;">​</a></h1><p>在Java中，基本我们说的线程（Thread）实际上应该叫作“用户线程”（Platform Thread），而对应到操作系统，还有另外一 种</p><p>线程叫作“内核线程”（OS Thread）。</p><p>即一个用户线程对应一个内核线程，内核负责每个线程的调度。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1695804256019/22ccbfae8ec64276827d70a1f80c5d68.png" alt="image.png" loading="lazy"></p><p><strong>优点：</strong></p><p>（比如JVM几乎把所有对线程的操作都交给了内核）实现线程模型的容器（jvm）简单，所以我们</p><p>经常听到在java中使用线程一定要慎重就是这个原因；</p><p><strong>缺点：</strong></p><p>对用户线程的大部分操作都会映射到内核线程上，引起用户态和内核态的频繁切换；</p><p>内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响；</p><p>虚拟线程：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/5983/1695804256019/92a21dd3ad5040e684233178dbbb17f2.png" alt="image.png" loading="lazy"></p><p>将多个虚拟线程映射到少量的实际线程上，并通过虚拟线程调度器来实现它们之间的切换。</p><p>具体来说：</p><ol><li>虚拟线程的创建：开发者可以通过API创建虚拟线程，并指定其运行的任务或代码块。</li><li>虚拟线程调度器：负责管理和调度所有的虚拟线程。调度器会根据一定的策略，将虚拟线程分配给实际线程执行。</li><li>虚拟线程切换：当一个虚拟线程遇到阻塞或需要让出CPU时，调度器会将其切换到其他可用的虚拟线程上执行。这个切换过程是基于应用级别的切换，比传统线程的上下文切换更轻量级。</li><li>虚拟线程的执行：实际线程会按照调度器的安排，执行分配给它的虚拟线程。每个虚拟线程都会有自己的执行流，可以独立地执行任务。</li></ol>`,142),l=[p];function e(h,k,r,E,d,o){return a(),i("div",null,l)}const y=s(t,[["render",e]]);export{c as __pageData,y as default};

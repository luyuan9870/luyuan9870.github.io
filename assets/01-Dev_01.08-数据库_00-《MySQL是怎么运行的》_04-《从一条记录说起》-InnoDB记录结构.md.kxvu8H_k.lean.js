import{_ as o,D as t,c as d,l as a,a as s,I as i,w as n,a4 as l,o as h}from"./chunks/framework.rIDq68an.js";const K=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.08-数据库/00-《MySQL是怎么运行的》/04-《从一条记录说起》-InnoDB记录结构.md","filePath":"01-Dev/01.08-数据库/00-《MySQL是怎么运行的》/04-《从一条记录说起》-InnoDB记录结构.md"}'),c={name:"01-Dev/01.08-数据库/00-《MySQL是怎么运行的》/04-《从一条记录说起》-InnoDB记录结构.md"},p=a("code",null,"Mysql",-1),_=a("code",null,"sql",-1),r=a("code",null,"mysql",-1),k=a("strong",null,"那么表中的数据存储到哪里了? 存储的是什么格式? 怎么存储的? 又是怎么访问这些数据的?",-1),u=a("code",null,"Mysql",-1),y=a("code",null,"存储引擎",-1),f=a("code",null,"Mysql",-1),F=a("code",null,"InnoDB",-1),g=a("code",null,"MyISAM",-1),B=a("code",null,"Memory",-1),E=a("h2",{id:"innodb-页简介",tabindex:"-1"},[s("InnoDB 页简介 "),a("a",{class:"header-anchor",href:"#innodb-页简介","aria-label":'Permalink to "InnoDB 页简介"'},"​")],-1),m=a("code",null,"InnoDB",-1),b=a("code",null,"Innodb",-1),C=a("code",null,"预读",-1),D=a("code",null,"Mysql",-1),q=a("code",null,"预读",-1),A=a("code",null,"InnoDB",-1),I=a("code",null,"页",-1),T=a("code",null,"16KB",-1),M=a("code",null,"页",-1),S=l("",9),v=a("strong",null,"为了描述当前这行信息不得不额外做的记录信息",-1),P=l("",2),V=a("li",null,"真正的数据内容 (可变字段)",-1),x=a("code",null,"Compact",-1),N=l("",4);function R(L,w,Q,$,O,H){const e=t("font");return h(),d("div",null,[a("blockquote",null,[a("p",null,[s("至今为止, "),p,s(" 还是一个黑盒, 在使用层面我们只需要在客户端编写好 "),_,s(" 发送给 "),r,s(" 服务端之后等待服务器的返回结果. "),k,u,s(" 服务端的数据存储和处理是由 "),y,s(" 来进行处理的, "),f,s(" 中由有很多不同的存储引擎 "),F,s(),g,s(" 等, 这些不同的存储引擎一般是由不同的人为实现不同的特性而开发的. "),i(e,{color:"#ff0000"},{default:n(()=>[s("真实数据在不同的存储引擎上存放的格式也是不同的")]),_:1}),s(", 甚至有的存储引擎压根就没有做数据刷盘的操作, 例如 "),B,s(" 这种引擎直接就是在内存上进行操作的, 当 Mysql 服务端发生关闭/重启时数据就全部丢掉了.")])]),E,a("blockquote",null,[a("p",null,[m,s(" 是一个将数据处理到磁盘中的存储引擎, 也就是它会把数据库持久化到磁盘中, 这个操作是在内存中实现的. 而内存与磁盘的读写速度差距很大. "),b,s(" 又是如何解决这个问题的呢?, 为了提升效率, 尽量减少磁盘 IO. 读取磁盘时往往不是严格的按需读取, 而是每次都会 "),C,s(" 即使当前只需要 1 个字节的数据, "),D,s(" 也是会从这个位置开始顺序往后读取一定长度的数据放入内存,这个称之为 "),q,s(". "),A,s(" 的基本单元叫 "),I,s(" 每一页数据"),i(e,{color:"#ff0000"},{default:n(()=>[s("一般")]),_:1}),s("有 "),T,s(" (默认), 不管是写入到内存中还是读取到磁盘中, 都是以 "),M,s(" 来作为基本单元的数据操作")])]),S,a("blockquote",null,[a("p",null,[s("Mysql "),v,s(", 总共有三大类 "),i(e,{color:"#ffff00"},{default:n(()=>[s("变长字段长度列表")]),_:1}),s(" 、"),i(e,{color:"#ffff00"},{default:n(()=>[s("Null 值列表")]),_:1}),s(" 、"),i(e,{color:"#ffff00"},{default:n(()=>[s("记录头信息")]),_:1})])]),P,a("ol",null,[V,a("li",null,[s("占用的字节数 (长度) 在 "),x,s(" 中, 把所有变长字段的真实数据、占用的字节长度都存放在记录的开头部位，从而形成一个变"),i(e,{color:"#ffff00"},{default:n(()=>[s("长字段长度列表")]),_:1}),s(" , 每个变长字段数据及其占用的字节数"),i(e,{color:"#ffff00"},{default:n(()=>[s("按照列的顺序逆序存放")]),_:1}),s(". 所有的数据都是"),i(e,{color:"#ffff00"},{default:n(()=>[s("逆序存放")]),_:1}),s("的 把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放")])]),N])}const X=o(c,[["render",R]]);export{K as __pageData,X as default};

import{_ as i,c as l,o as e,a4 as p}from"./chunks/framework.rIDq68an.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.08-数据库/03-Redis/Redis.md","filePath":"01-Dev/01.08-数据库/03-Redis/Redis.md"}'),s={name:"01-Dev/01.08-数据库/03-Redis/Redis.md"},a=p('<ol><li>Redis 快的原理 <ol><li>优雅的数据结构 <ol><li>动态字符串</li><li>双端链表</li><li>压缩列表</li><li>跳表</li></ol></li><li>单线程的存取模型,没有上下文切换</li><li>IO的多路复用</li></ol></li></ol><ul><li><p>Redis 存储数据的细节问题</p></li><li><p>缓存穿透、缓存击穿、缓存雪崩都是什么，并且怎么解决</p></li><li><p>穿透： 原因是缓存和数据库中都没有的数据，可能会给缓存/数据库带来一些性能压力，可以采用缓存一个短时效性的默认值来防止数据库的访问压力，当数据库被写入或者更新该key的数据时，缓存必须同时刷新来避免数据库不一致的问题</p></li><li><p>击穿： 原因是热点数据失效，导致大量的请求落到了数据库上可能会给数据库带来一些性能压力，可以通过设置key永不过期，然后在后台更新缓存</p></li><li><p>雪崩：原因是大量的缓存数据同一时间全部失效或者Redis 宕机，这个可以设置不通的过期时间来解决该问题</p></li><li><p>Redis 的热点key问题如何解决</p></li><li><p>可以设置永不过期， 然后由子线程或者MQ等技术来实现更新热点数据的操作。</p></li><li><p>Redis的应用场景，存放哪些数据，有哪些特点</p></li><li><p>缓存一些数据，计数器、分布式锁、全局ID、标签、数据字典</p></li><li><p>redis天生就是原子性，每一个操作都是原子性的，对数据的更改要么全部成功，要么全部失败</p></li><li><p>redis 有事务支持</p></li><li><p>Redis的数据类型，Redis 是单线程还是多线程</p></li><li><p>Redis是多线程的，严格意义上说， 它的网络IO和数据读写是单线程的，但是像数据持久化，异步删除等操作还是由其他线程来执行的</p></li><li><h2 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h2><ul><li>String ：可以实现 像计数器，分布式ID，分布式锁，等业务场景 <ul><li>常用的命令： set、get等</li><li>是一种最常用的数据类型，普通的keyValue数据都可以用string来存储</li><li>String类型在Redis中就是用C构建的一个字符串</li></ul></li><li>Hash： 适合存储对象，KV结构 <ul><li>常用命令：hget、hset、hgetall等</li></ul></li><li>List： 有序可重复，是一个列表</li><li>Set：无序不可重复</li><li>ZSet： 可以实现排行榜</li></ul></li><li><p>redis 虽然提供了多种数据类型，但是实际使用时 都可以用String来做 通过Java代码的序列化成JSON字符串 存入Redis。</p></li><li><p>Redis如何保证数据一致性问题1) 先更新数据库，在更新缓存。（先读数据库，数据库中没有再去读缓存，写的时候先写数据库，再将数据库的数据写入到缓存）。缓存可能会更新失败，读取到老的数据从而产生数据不一致问题2） 先删除缓存，在更新数据库。当并发量高的时候，数据库的写操作可能还没有来得及提交数据，此时另外一个线程读取到数据还是会产生（）就是先操作数据库还是先操作缓存的问题延迟双删的方案先删除缓存，在去更新数据库，然后休眠多少毫秒（这个需要程序员去预估）在删除缓存这样等下次请求进来的时候 缓存中没有数据，就会读取数据库并重新写入缓存</p></li><li><p>Redis 实现分布式锁</p></li></ul><p>采用SetNx命令， 这个命令可以判断当前key是否存在，如果存在就获取锁， 如果不存在就获取不到锁。</p><p>采用Lua脚本可以实现 多命令的原子性操作。</p><p>考虑到锁过期问题，还需要启动一个子线程来定时监听锁是否需要续期</p><p>原理就是通过setnx来抢占锁，之后再给当前锁加入过期时间来防止死锁</p><ul><li><p>Redis的持久化操作</p></li><li><p>RDB 快照数据, 比较快, 但是容易丢失数据.不是很安全.</p></li><li><p>在指定的间隔时间内，将Redis内存中的所有数据进行一个快照备份写入到磁盘文件中</p></li><li><p>快照完成之后会产生一个 dump.rdb文件，方便持久化</p></li><li><p>容灾性好，方便备份</p></li><li><p>相对于数据量大的情况下，比AOF的启动效率要高。</p></li><li><p>对于大规模的数据恢复 对数据的完整性要求不高的情况下。恢复数据的速度特别快</p></li><li><p>AOF AOF是 记录命令.安全 但是比较慢</p></li><li><p>以日志的形式来记录每一次Redis 操作的命令（不包含查询），</p></li><li><p>Redis 对AOF提供了三种同步策略，每秒同步，每个命令同步和不同步三种</p></li><li><p>采用Append追加模式，数据安全</p></li></ul><h4 id="内存淘汰策略" tabindex="-1">内存淘汰策略 <a class="header-anchor" href="#内存淘汰策略" aria-label="Permalink to &quot;内存淘汰策略&quot;">​</a></h4><p>Redis 在64位系统中 默认是不限制 内存大小的，在32位系统中 默认是最大3GB，可以通过redis.conf配置文件中的maxmemory参数设置最大的内存值。或者是通过config set maxmemory</p><p>Redis 有两种内存淘汰策略</p><ol><li><p>第一种是 TTL过期删除策略</p></li><li><p>根据过期时间，采用懒删除和定时删除的两种模式</p></li><li><p>懒删除就是 当TTL过期的时候，不会立即删除 当前key，而是当访问这个key的时候去判断当前的过期时间是否已经过期</p></li><li><p>定时删除 每个一段时间 Redis会扫描一定数量的key，当过期key的数量超过了扫描数量的25%就会删除其中已经过期的key</p></li><li><p>第二种是内存淘汰的策略</p></li></ol><ul><li><p>Redis的过期删除策略，缓存过期之后是立即删除吗？ 如果不是 那么它底层是怎么进行删除的</p></li><li><p>Redis 不会立即删除过期内存， 它采用的是惰性删除和定时删除，因为如果是实时删除的话会占用较高的CPU资源</p></li><li><p>惰性删除： 只有当访问这个key的时候，才会判断这个key有没有过期。这种策略极大的节省了CPU的资源，但是对内存不是很友好，极端情况下可能会有大量的过期缓存没有被再次访问，导致不会被清除从而造成了内存的浪费</p></li><li><p>定时删除： 每隔一段时间，Redis会扫描一定数量（设置了过期时间的）key，并清除其中已经过期的key。使CPU和内存达到平衡</p></li><li><p>Redis的拒绝策略Redis共有八种拒绝策略LRU算法： 淘汰距离上次使用最早，次数最少的key</p></li><li><p>默认是noeviction 不回收 当Redis的内存超过使用配置的阈值时，在添加新的内存 它会返回错误， 不会驱逐任何的key</p></li><li><p>Volatile-lru （推荐的拒绝策略）：使用LRU算法进行数据淘汰（淘汰距离上次使用最早，并且次数最少的key），只淘汰设定了有效期的key</p></li><li><p>allkeys-lru：使用LRU算法进行数据淘汰，这种拒绝策略可以淘汰所有的key</p></li><li><p>allKeys-LFU ： 淘汰所有key中使用频率最少的key</p></li><li><p>allkeys-Random： 随机淘汰数据，这种拒绝策略可以淘汰所有的key</p></li><li><p>Volatile-Random ： 随机淘汰数据，只淘汰设定了有效期的key</p></li><li><p>Volatile-TTL： 淘汰剩余有效期最短的key</p></li><li><p>Volatile-LFU ：淘汰所有配置了过期时间，里面使用频率最少的key</p></li></ul>',12),d=[a];function t(o,r,R,n,k,y){return e(),l("div",null,d)}const u=i(s,[["render",t]]);export{c as __pageData,u as default};

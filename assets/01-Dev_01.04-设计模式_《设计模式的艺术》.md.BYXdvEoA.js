import{_ as a,c as o,o as e,a4 as t}from"./chunks/framework.BG61BEI0.js";const r="/assets/image-20240707181542359.DN0PWzEC.png",l="/assets/image-20240707180148882.jrJb5qqq.png",q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.04-设计模式/《设计模式的艺术》.md","filePath":"01-Dev/01.04-设计模式/《设计模式的艺术》.md"}'),n={name:"01-Dev/01.04-设计模式/《设计模式的艺术》.md"},s=t('<blockquote><p>软件开发的内功修炼：数据结构、算法、设计模式、重构、软件工程</p></blockquote><p><strong>前言：</strong> 个人认为软件的演进过程或者说开发过程，在实际当中不一定非要使用很多的设计模式，就像 DDD 一样。 我理解的不管是设计模式也好还是 DDD 也好。其实都会带来一些问题，比如：类爆炸，过于抽象化的不好理解。 所以：<strong>没有绝对的银弹，只有合适的方案。</strong></p><p><strong>什么是设计模式？</strong> ： 在特定的环境下，解决某类重复出现问题的一套成功/有效的解决方案。</p><h2 id="整体总结介绍" tabindex="-1">整体总结介绍 <a class="header-anchor" href="#整体总结介绍" aria-label="Permalink to &quot;整体总结介绍&quot;">​</a></h2><h3 id="uml-类图" tabindex="-1">UML 类图 <a class="header-anchor" href="#uml-类图" aria-label="Permalink to &quot;UML 类图&quot;">​</a></h3><h3 id="uml-类图是什么" tabindex="-1">UML 类图是什么 <a class="header-anchor" href="#uml-类图是什么" aria-label="Permalink to &quot;UML 类图是什么&quot;">​</a></h3><p>集百家之长的一坨构建模型的符号与标记的语言。</p><p><strong>组成部分</strong>： （这部分仿佛在解释，什么是流程图，什么是泳道图，什么是结构图）</p><ul><li>视图： 多个图，组合而成的抽象集合，包括不限于：（用户、行为、实现、环境）多个视图。</li><li>图：UML 2.0 提供了多种图，（用例、对象、包、组合结构、状态、活动、顺序、交互、通信）等等</li><li>模型元素： 用于表达 <code>关系</code> 。类、对象、消息、行为。（关联、依赖、泛化、调用）关系的一坨符号</li><li>通用机制：写一些备注，名称，便于更高效的理解</li></ul><p><strong>人话版本</strong>：通过一坨符号（空心方块，实心方块，虚线，实线，类，对象，组合，包含，关联）来构建成 <code>视图</code></p><p><img src="'+r+'" alt="" loading="lazy"></p><p><strong>能干什么？解决了什么问题？</strong> 帮助人们，理解 <code>一招一式</code></p><h3 id="面向对象的七大原则" tabindex="-1">面向对象的七大原则 <a class="header-anchor" href="#面向对象的七大原则" aria-label="Permalink to &quot;面向对象的七大原则&quot;">​</a></h3><p><strong>单一职责：</strong> 针对类/方法只做一件事，只做一个类型的事。强调的是最小单元，高内聚低耦合的系统。</p><p><strong>开闭原则：</strong> 对新增开放，对修改关闭。满足开闭原则需要在程序上进行一些抽象设计。比如策略模式对 Ifelse 的优化。</p><p><strong>里氏替换：</strong> 人话： 针对多态的情况，通过父类引用指向子类对象时，完全满足父类对象的 <code>原始需求</code> ，我喜欢一个动物，它是狗。但是我不喜欢老鼠这个动物。</p><p><strong>依赖倒转：</strong> 抽象不应该依赖于细节，细节应该依赖于抽象。要针对接口编程，而不是针对实现编程。（Spring 的 DI 就是经典的应用代表）</p><p><strong>接口隔离：</strong> 使用多个专门的接口，而不使用单一的总接口，客户端不应该依赖那些它不需要的接口。</p><p><strong>合成复用：</strong> 少些 CV 操作，多些 <code>ctrl</code> + <code>alt</code> + <code>m</code> 的方法抽取。尽量使用对象组合来满足多项复用</p><p><strong>迪米特：</strong> 人话：不要和陌生人说话，<code>PO、DO、VO、QO</code> 的经典应用。</p><h3 id="创建的艺术" tabindex="-1">创建的艺术 <a class="header-anchor" href="#创建的艺术" aria-label="Permalink to &quot;创建的艺术&quot;">​</a></h3><h4 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to &quot;单例模式&quot;">​</a></h4><ul><li><strong>单例模式的背景：</strong> 确保对象的唯一性，不管 CPU 上下文切换调度的任何操作，我能保证全局唯一，任何人看到的都是一样的。</li><li><strong>单例模式的经典应用：</strong> windows 的任务管理器是不允许多开实例的。内容都是一样的，如果多开展示的都是重复内容，对系统的资源是一种浪费。</li><li><strong>单例的优点：</strong> 全局唯一的实例访问、节约系统资源，允许可变数目的实例，可以扩展成多例类类似于线程池。</li></ul><h4 id="工厂模式" tabindex="-1">工厂模式 <a class="header-anchor" href="#工厂模式" aria-label="Permalink to &quot;工厂模式&quot;">​</a></h4><h3 id="组合的艺术" tabindex="-1">组合的艺术 <a class="header-anchor" href="#组合的艺术" aria-label="Permalink to &quot;组合的艺术&quot;">​</a></h3><h3 id="交互的艺术" tabindex="-1">交互的艺术 <a class="header-anchor" href="#交互的艺术" aria-label="Permalink to &quot;交互的艺术&quot;">​</a></h3><h2 id="感悟和启发" tabindex="-1">感悟和启发 <a class="header-anchor" href="#感悟和启发" aria-label="Permalink to &quot;感悟和启发&quot;">​</a></h2><p>个人粗浅的认为，这些所谓的设计模式，其实本质上都是针对面向对象思想的核心应用。</p><p>多思考，多实践，多说多做。</p><ul><li>这个设计模式背后的意图是什么？</li><li>他要解决什么问题？他是怎么解决的？他的结构是怎样的?</li><li>我什么时候使用？</li><li>我需要记住什么关键信息? 如何联想生活中的 case和软件领域的 case 帮我更快的理解这个东西？</li></ul><h2 id="书中关联" tabindex="-1">书中关联 <a class="header-anchor" href="#书中关联" aria-label="Permalink to &quot;书中关联&quot;">​</a></h2><p><strong>volatile 关键字</strong> : 针对双重检查锁, 通过 Volatile 来禁止指令重排序和保证线程可见性。JVM 针对 Volatle 会屏蔽 JVM 所做的一些代码优化，可能会导致系统运行效率的降低。因为不允许指令重排序，就是可能会导致效率降低。</p><h2 id="摘抄" tabindex="-1">摘抄 <a class="header-anchor" href="#摘抄" aria-label="Permalink to &quot;摘抄&quot;">​</a></h2><p><strong>设计模式的学习难度与使用频率</strong><img src="'+l+'" alt="" loading="lazy"></p>',34),i=[s];function c(d,h,p,g,u,_){return e(),o("div",null,i)}const b=a(n,[["render",c]]);export{q as __pageData,b as default};

import{_ as p,c as t,o as n,a4 as r}from"./chunks/framework.BG61BEI0.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.04-计算机基础/基础数据结构/小陈.md","filePath":"01-Dev/01.04-计算机基础/基础数据结构/小陈.md","lastUpdated":1712823825000}'),s={name:"01-Dev/01.04-计算机基础/基础数据结构/小陈.md"},o=r('<h4 id="数据结构与算法" tabindex="-1">数据结构与算法 <a class="header-anchor" href="#数据结构与算法" aria-label="Permalink to &quot;数据结构与算法&quot;">​</a></h4><p>数据结构：数组、链表、队列。</p><p><strong>1、数据结构（书）：</strong></p><p>1）数据结构与算法严蔚敏版</p><p>2）大话数据结构</p><p><strong>2、算法书</strong></p><p>1）基础级：算法竞赛入门经典（两本，还有一个是习题）刘汝佳</p><p>2）进阶级：刘汝佳黑书（算法艺术与信息学竞赛） 算法导论非常难</p><p><strong>3、刷题网站</strong></p><p>1）力扣</p><p>2）POJ（北大的算法题库） or HDU（杭州电子科技大学）</p><p>时间复杂度：运行一个程序所花费的时间，O ()；（某一段代码）</p><p>空间复杂度：运行程序所需要的内存，OOM。</p><p><strong>一、几种常见的时间复杂度分析：</strong></p><p>计算时间复杂度往往是计算比较大的而且是不确定的数，如果已经确定了，那么就不用计算了，也就是我们说的常量。</p><p>1）常数阶：O (1)，1 表示常数，所有能确定的数字我们都用 O (1)。O (1000)=&gt;O (1)；</p><p>2）对数阶：O (logn)、O (nlogn)</p><p>3）线性阶：O (n)</p><p>4）线性对数阶：O (nlogn)</p><p>5）平方阶：O (n²)</p><p>6）N 次方阶：O (nⁿ)</p><p>我们怎么找时间复杂度：</p><p>1）找到有循环的地方；</p><p>2）找到网络请求（RPC、远程调用、分布式、数据库请求）的地方。</p><p>几种常见的时间复杂度总结：</p><p>学习时间复杂度，目的就是要把代码写到最优、效率最高！！</p><p>O (1) &gt; O (logn) &gt; O (n) &gt; O (nlogn) &gt; O (n²) &gt; O (nⁿ)</p><p>O (1) &gt; O (logn) &gt; O (n) &gt; O (nlogn)效果都是很好的，几乎优化的空间不是很大。</p><p>优化的目标就是要往 O (1)的方向接近，<strong>O (1)是最快的</strong>。</p><p><strong>二、基础数据结构：数组&amp;链表</strong></p><p><strong>面试经典：</strong></p><p>给你一个文件里面包含全国人民（14 亿）的年龄数据（0~180），现在要你统计每个年龄有多少个人？给定机器为单台+2 CPU+2 Gnnei 内存，不得使用现成的容器，比如 map 等，再以上的情况下该如何以最有效的方法来解决这个问题？</p><p>用数组</p><p><strong>一）数组的定义</strong>：</p><p>数组，是有序的元素队列，数据类型一致。</p><p><strong>特点</strong>：</p><p>1）数组是相同数据类型的元素的集合；</p><p>2）数组中的各元素的存储是有序的，它们在内存中按照这个先后顺序连续存放在一起，内存地址。（查询快、增删慢、适合随机访问：可以直接通过下标定位到数组中的某一个数据。时间复杂度为 O (n)）</p><p>什么是堆内存？存放 new 创建的对象和数组</p><p>什么是栈内存？引用变量</p><p>堆栈的区别：</p><p>1）栈的速度更快；</p><p>2）栈内存的数据可以共享，主要存一些基本数据类型。</p><p><strong>二）链表的定义</strong>：</p><p>链表通过指针将一组零散的内存块串联在一起，其中，我们把内存块称为链表的“结点”，为了把所有的结点串起来，每个链表的节点除了存储数据之外，还需要记录链上的下一个节点的地址。</p><p>头节点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表。而尾节点特殊的地方是，指针不是指向下一个节点，而是指向一个空地址 NULL，表示这是链表上最后一个节点。</p><p><strong>特点</strong>：</p><p>1）不需要连续的内存空间；</p><p>2）有指针引用；</p><p>3）三种常见的链表结构：单链表、双向链表和循环链表。</p><p>单向链表链表只有一个方向，节点只有一个后续指针 next 指向后面的节点。双向链表它支持两个方向，每个节点不止有一个后续指针 next 指向后面的节点，还有一个前驱指针 prev 指向前面的节点。所以如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历。</p><p><strong>循环链表：</strong></p><p>循环列表的尾节点是指向链表的头节点。</p><p>B+Tree MySQL 索引叶子节点双向列表</p><p><strong>链表和数组的重要区别：</strong></p><p>1）数组在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高；</p><p>2）链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读；</p><p>3）数组的缺点是大小固定，一经声明就要占用整块连续内存空间，如果声明数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out ofmemory）”，如果声明数组过小，则可能出现不够用的情况；</p><p>4）动态扩容：数组需要申请一个更大的内存空间，把原数组拷贝进去，非常费时，链表本身没有大小的限制，天然支持动态扩容。</p><p><strong>三）栈</strong></p><p>后进先出（一摞盘子），栈其实就是一个特殊的链表或者数组</p><p><strong>栈的分类：</strong></p><p>1）基于数组的栈——以数组为底层数据结构时，通常以数组头为栈底，数组头到数组尾为栈顶的生长方向；</p><p>2）基于单链表的栈——以链表为底层数据结构时，以链表头为栈顶，便于节点的插入与删除，进栈产生的新节点将一直出现在链表的头部。</p><p>最大的<strong>区别</strong>就是扩容，链表天然支持动态扩容，但是可能栈溢出。</p><p><strong>四）队列（FIFO、排队买票、先进先出）</strong></p><p><strong>队列的分类：</strong></p><p>1）<strong>顺序（单向）队列</strong>：（Queue）只能在一端插入数据，另一端删除数据；</p><p>2）<strong>循环（双向）列表</strong>：（Deque）每一端都可以插入和删除数据；</p><p>链表可以无限扩容（需要控制好大小）</p><p>3）<strong>循环队列</strong>怎么判断队列已满：（tail+1）%n==head；</p><p>4）<strong>优先队列</strong>：回到排队买票场景，有些 vip 用户，总是可以插队。优先队列其实就是在插入的时候排了序而已；</p><p>5）<strong>阻塞队列</strong>：</p><p><strong>三、算法思想：数论&amp;枚举&amp;递归&amp;分治&amp;回溯</strong></p><p>斐波那契数列：1 1 2 3 5 8 13 21，从第三个数开始就等于前面两个数相加。</p><p>求解公式：f (n) = f (n-1)+f (n-2)</p><p>终止条件：n&lt;=2 f (n)=1</p><p>数论思想：利用数学公式或者定理或者规律求解问题。</p><p>算法思想中最难的点：递归、动态规划（可以不用太懂）；</p><p>树论：二叉树、红黑树。</p><p><strong>一）递归（方法调方法）</strong></p><p>自己调自己</p><p>什么情况下用递归？</p><p>1）一个问题的解可以分解为几个子问题的解；子问题，我们通过分治的思想可以把一个数据规模大的问题，分解为很多小的问题；</p><p>2）这个问题与分解之后的子问题，求解思路完全一样；</p><p>3）一定有个最后确定的答案，即递归的终止条件。</p><p>递归优化：</p><p>1）使用非递归：所有的递归代码理论上是一定可以转换成非递归的；</p><p>2）加入缓存：把中间的运算结果保存起来，这样就可以递归降至 O (n)；</p><p>3）尾递归：尾递归就是调用函数一定出现在末尾，没有其他的操作了。因为我们编译器在编译代码时，如果发现函数末尾已经没有操作了，这时候就不会创建新的栈，而且覆盖到前面去。</p><p><strong>二）排序</strong></p><p>所知道的排序算法有哪些？</p><p>快速排序、冒泡排序、希尔排序、二分排序（二路归并 O (nlogn)）、桶排序、堆排序、基数排序、插入 O (n²) 、选择排序。</p><p>插入&amp;希尔&amp;归并：递进</p><p>冒泡&amp;选择&amp;快速：递进</p><p>堆排序：树论高级篇里面</p><p>1）<strong>插入排序</strong>：打扑克。分成两部分：一部分是你手里的牌（已经排好序），一部分是你要拿的牌（无序），把一个无序的数列一个个插入到有序数列中。</p><p>往一个有序的集合里面插入元素，插入后序列仍然有序这就是插入排序算法思路。插入排序具体实现步骤：</p><p>A、将数组分为已排序段和未排序段，初始化时已排序段只有一个元素；</p><p>B、到未排序段取元素插入到已排序段，并保证插入后依然有序；</p><p>C、重复执行上述操作，直到未排序段元素全部加完。</p><p>2）<strong>希尔排序</strong>：其实是插入排序的改进版。</p><p>3）<strong>归并排序</strong>：</p><p>4）<strong>选择排序（项目里基本不用）</strong>：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><p>5）<strong>冒泡排序</strong>：只会操作相邻的两个数据，如果不满足大小关系就让它俩互换。</p><p>A、冒泡排序，是通过每一次遍历获取最大/最小值</p><p>B、将最大值/最小值放在尾部/头部</p><p>C、然后除开最大值/最小值，剩下的数据在进行遍历获取最大/最小值</p><p>6）<strong>快速排序</strong>：基准数：一般就是取要排序序列的第一个。</p><p>A、从后面往前找到比基准数小的数进行对换；</p><p>B、从前面往后找到比基准数大的数进行对换；</p><p>C、以基准数分为三部分，左边的比之小，右边的比之大。</p><p><strong>优化</strong>快速排序就是优化基准数（最常用三数取中），方法还有很多种。</p><p><strong>快排和归并的对比：</strong></p><p>A、归并排序的处理过程是由下到上的，先处理子问题，然后再合并；</p><p>B、快排就是从上到下，先分区，再处理子问题，不用合并。</p><p>总结：数据量小的时候优先选插入排序，不会分析的情况下，选择归并或快排。</p><p><strong>三）贪心算法&amp;动态规划</strong></p><p>动态规划是算法里最难的算法。（可以不用掌握）</p><p>贪心算法：通过局部最优，推出全局最优。（一定会有排序）</p><p><strong>四、高级数据结构：树论基础&amp;二叉树</strong></p><p>结点高度：结点到叶子结点的最长路径；</p><p>结点的深度：根结点到该结点的边个数；</p><p>结点的层数：结点的深度加 1；</p><p>树的高度：根结点的高度。</p><p><strong>一）二叉树</strong></p><p>平衡二叉树</p><p>二叉查找树</p><p>B 树（B-Tree、B+Tree）：不是二叉树，是 N 叉（多叉）。</p><p>红黑树</p><p>完全二叉树（avl 树）：堆排序</p><p>BinaryTree（二叉树）的特点：</p><p>1）每个节点至多只有两颗子树；</p><p>2）在二叉树的第 N 层上至多有 2*（N-1）个结点，最多有 2*N-1 个结点个数；</p><p>3）满二叉树：除叶子结点外，每个结点都有左右两个子结点；</p><p>4）完全二叉树：除最后一层外，其他的结点个数必须达到最大，并且最后一层结点都连续靠左排列。</p><p><strong>二）二叉搜索树&amp;红黑树</strong></p><p>二叉搜索树：又叫二叉查找树、二叉排序树。</p><p><strong>特点</strong>：</p><p>1）如果它的左子树不为空，则左子树上结点的值都小于根结点；</p><p>2）如果它的右子树不为空，则右子树上结点的值都大于根结点；</p><p>3）子树同样也要遵循以上两点。</p><p><strong>红黑树</strong>:</p><p>1）根节点是黑色的；</p><p>2）每个节点非黑即红；</p><p>3）每个叶子节点或空节点都是黑色；</p><p>4）每个红节点的两个子节点都是黑色的；（不存在两个连续的红色节点）</p><p>5）任一节点到它叶节点的所有路径都包含相同数目的黑色节点。（新节点默认给红色）</p><p>左旋的条件：</p><p>1）父节点是红色；</p><p>2）叔叔结点是黑色；</p><p>3）当前点是右子树，以父节点左旋。</p><p>右旋的条件：</p><p>1）父节点是红色；</p><p>2）叔叔结点是黑色；</p><p>3）当前点是左子树，把父亲变为黑色，爷爷变为红色，以爷爷结点右旋</p><p><strong>三）BTree &amp; B+Tree</strong></p><p>IO：指的是从磁盘读取数据。</p><p>二叉树比 B+Tree 更快，二叉树是存在内存里的</p><p>主键索引和辅助索引有什么区别？</p><p>辅助索引存的是主键索引的值，真正取数据的时候会从主键索引里面取数据</p><p><strong>四）Trie 树 &amp; 赫夫曼树</strong></p><p>满二叉树：除了叶子节点都有两个子节点；</p><p>完全二叉树：除了最底层都有两个子节点，而且叶子节点是靠左连接的。</p><p><strong>最优二叉树就是赫夫曼树</strong>：给定 N 个权值作为 N 个叶子节点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（HuffmanTree），哈夫曼树是带权路</p><p>径长度最短的树，权值较大的结点离根节点较近。</p><p><strong>具体实现思路</strong>：</p><p>1）每次取数值最小的两个节点，将之组成一棵子树；</p><p>2）移除原来的两个点；</p><p>3）然后将组成的子树放入原来的序列中；</p><p>4）重复执行 1 2 3 直到只剩最后一个点。</p><p>小的放左边</p><p>JDK 底层的优先队列：PriorityQueue</p><p><strong>五）堆树</strong></p><p>完全二叉树：除了最后一层，其他层每个节点都是满的且最后一层的节点都要靠左排列。（是用数组存储的，直接利用下标就可以表示左右节点）</p><p>左右节点的公式：</p><p>左=2*i（i 就是当前节点所在数组的下标）</p><p>右=2*i+1</p><p>二叉搜索树：左节点小于根节点，右节点大于根节点。</p><p>堆是一种特殊的树，需要满足以下两点：</p><p>1）是一棵完全二叉树；</p><p>2）每一个节点的值都大于等于或者小于等于其左右子节点的值。</p><p>：</p><p>堆的插入有两种实现方式：</p><p>1）从下往上（修正，从后往前，从数组的后面往前走）：</p><p>2）从上往下（从无到有）：</p><p>大顶堆：</p><p>其插入过程就叫做堆化。</p><p>利用堆树进行排序：</p><p>1）先按照序列顺序存储在完全二叉树中；</p><p>2）从最后一个非叶子节点堆化。为什么是最后一个非叶子节点而不是最后一个叶子节点呢？叶子节点没必要堆化</p><p><strong>六）图论基础</strong></p><p>1、<strong>什么是图</strong>：图（Graph）是一种非线性数据结构，比较复杂，图没有层的概念，它们之间的任意元素都可能产生关系。</p><p>2、图的基本知识：</p><p>1）顶点：</p><p>2）边：</p><p>3）顶点的度：</p><p>4）出度、入度：</p><p>5）有向图、无向图：</p><p>搜索算法最基础的两种：</p><p>1）深度优先遍历（DFS）：一条路走到底，递归、有回溯，也要标记走过的点；关键的优化剪枝</p><p>2）广度优先遍历（BFS）：把所有的路都走了</p><p>两个关键点：队列、标记数据，加过的点不能再加</p><p><strong>七）最短路径：迪杰斯特拉算法</strong></p><p>线性表：数组和链表</p><p>非线性表：树+图</p><p>迪杰斯特拉算法的时间复杂度</p><p><strong>五、高效查找法：二分&amp;HashMap</strong></p><p>Hash 查找的时间复杂度是 O (1)，这一特性就可以实现快速判断元素是否存在序列当中。</p><p>取余%就是散列函数的一种</p><p><strong>开放寻址</strong>：核心思想是，如果出现了散列冲突，就重新探测一个空闲位置，将其插入。</p><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p><strong>缺点</strong>：</p><p>1）删除需要特殊处理；用-1 表示删除（还占用一个位置），用空间换时间;</p><p>2）插入的数据如果过多会导致散列表很多冲突查找可能会退化成遍历。</p><p><strong>链路地址</strong>：其实就是使用链表，链表法就是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多，在散列表中，每个 key 会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><p>加密：MD 5 哈希算法。</p><p><strong>Hash 扩容算法在多线程情况下有什么问题？</strong></p><p>1）数据容易丢失；2）容易出现闭环（死循环）。</p><p><strong>既然 Hash 扩容是线程非安全的，那我们该怎么用？</strong></p><p>1）使用了 hash 的系统尽可能单线程操作；</p><p>2）如果是多线程环境则要注意加锁，比如 jdk 里面就可以使用 ConCurrentHashMap；</p><p>计算机中最小的内存单位：bit（数据位）</p><p>位与 &amp; 同位上的两个数都是 1 则为 1，否则为 0</p><p>位或同位上的两个数只要有一个为 1 则为 1，否则为 0</p><p><strong>目前主要的容器存储结构</strong>：</p><p>List：有序可重复。</p><p>常用的实现方式：链表+数组（ArrayList、LinkedList、Vector）。</p><p>Set：无序不可重复。</p><p>HashSet 其内部是一个 Hash 表（HashMap）实现，是无序的，但是如果是 Integer 类型的在 jdk 1.8 是有序的。</p><p>TreeSet 里面的元素是<strong>自动排序</strong>的，底层是二叉树实现的，也就是红黑树。</p><p>常用的实现方式：HashSet、TreeSet、LinkedHashSet（强行保证输出顺序和插入顺序一致，双向链表，耗费空间）。</p><p>Map：键值对的形式，会有 key-value，不允许出现相同的 key，出现就会被覆盖。</p><p>主要实现方式：HashMap、HashTable、TreeMap（有序，底层同样是红黑树）</p><p><strong>布隆过滤器</strong>是一个非常巧妙的数据结构，在很多高并发大数据项目中都有应用，它的特点就是高效的查找和插入。核心：查不到的肯定不存在，能查到的有可能存在。</p><p>有哪些使用场景：（前提是得接受一定的误判率，大约 0.1%）</p><p>1、爬虫过滤；</p><p>2、缓存击穿：小数据量的直接用 hash，确定 id 的可以用 bitMap；</p><p>3、垃圾邮件过滤；</p><p>4、秒杀系统：重复买；</p><p>5、Hbase（大数据库 key-value）</p><p><strong>Lucene 倒排索引</strong></p><p>搜索引擎能解决什么问题？</p><p>高效：查询效率特别高</p><p>适合大数据：千万级</p><p>Lucene 与搜索引擎的关系：</p><p>Lucene 是搜索系统的核心框架，它类似 spring jar 包，只要把 jar 引入自己的工程就可以用，不依赖 es 和 solr（单机版--&gt;集群版）。</p><p>适合小规模的检索（10 万左右的数据）</p><p>分词规则：smart 和最小颗粒（IK 分词器）</p><p>面试中最常被问到的</p><p>数据结构类：</p><p>1、红黑树；</p><p>2、B 树：通过 mysql 来间接提问；</p><p>3、堆树</p><p>最熟悉的数据结构是什么，尽量从以上三个里面说</p><p>算法类：基础模块</p><p>1、排序和查找算法：快排、归并、二分；</p><p>2、链表：链表的优缺点，插入和删除，为什么访问要比数组慢；</p><p>3、数组：下标随机访问；</p><p>4、递归；</p><p>5、枚举；</p><p>6、栈 or 队列：计算表达式；</p><p>7、贪心：最短路径，会议室编排；</p><p>8、动态规划：一般会问背包问题、编辑距离问题、求最大和值、kmp（模式匹配）</p><p>算法类：大数据相关的</p>',265),g=[o];function e(a,i,O,m,l,h){return n(),t("div",null,g)}const d=p(s,[["render",e]]);export{c as __pageData,d as default};

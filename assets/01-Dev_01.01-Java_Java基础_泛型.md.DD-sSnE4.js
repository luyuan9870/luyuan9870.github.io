import{_ as a,c as e,o as t,a4 as s}from"./chunks/framework.BG61BEI0.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.01-Java/Java基础/泛型.md","filePath":"01-Dev/01.01-Java/Java基础/泛型.md"}'),n={name:"01-Dev/01.01-Java/Java基础/泛型.md"},o=s(`<h2 id="泛型是什么" tabindex="-1">泛型是什么 <a class="header-anchor" href="#泛型是什么" aria-label="Permalink to &quot;泛型是什么&quot;">​</a></h2><blockquote><p>对对象的一个占位符, 可表示已经确定的<strong>某些</strong>对象的<strong>参数化类型</strong> 当值不想设置为 Object 的时候, 可以采用泛型, 因为设置成为 Object 时需要程序员显式转换. 泛型与接口的作用很相似, 定义一个接口, 我们只需要调用接口, 而不关心它的具体实现. 泛型也是这个意思, 我给你一个碗不关心你拿碗盛饭盛菜还是盛汤</p></blockquote><p>泛型能干什么</p><p>泛型怎么用</p><h2 id="泛型通配符" tabindex="-1">泛型通配符 <a class="header-anchor" href="#泛型通配符" aria-label="Permalink to &quot;泛型通配符&quot;">​</a></h2><blockquote><p>通配符的作用是为了限制泛型的定义范围</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>&lt;?&gt; 无界通配符，即类型不确定，任意类型</span></span>
<span class="line"><span>&lt;T&gt; 同 ? </span></span>
<span class="line"><span>&lt;? extends T&gt; // 上边界通配符 , 必须是 T 类的子类, 遵守只读不写</span></span>
<span class="line"><span>&lt;? super T&gt; // 下边界通配符 , 必须是 T 的父类, 遵守只写不读</span></span></code></pre></div>`,7),p=[o];function c(l,r,i,_,d,h){return t(),e("div",null,p)}const g=a(n,[["render",c]]);export{v as __pageData,g as default};

import{_ as e,c as l,o as n,m as t}from"./chunks/framework.BG61BEI0.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01-Dev/01.04-设计模式/02-创建型/单例.md","filePath":"01-Dev/01.04-设计模式/02-创建型/单例.md"}'),s={name:"01-Dev/01.04-设计模式/02-创建型/单例.md"},o=t("p",null,"单例模式是一种创建型设计模式，它可以确保一个类只有一个实例，并提供全局访问点来访问该实例。以下是一些使用单例模式的原因：",-1),a=t("ol",null,[t("li",null,"避免资源竞争：在一个多线程环境中，如果没有使用单例模式，多个线程可能会同时创建多个实例，导致资源竞争和数据不一致。"),t("li",null,"节省内存：如果一个类有多个实例，那么它们会共享相同的内存空间。使用单例模式可以确保只有一个实例被创建，从而节省内存。"),t("li",null,"统一访问：如果一个类有多个实例，那么如果要访问其中的某个实例，就需要先找到它的实例。使用单例模式可以提供全局访问点，使得访问变得更加简单和统一。"),t("li",null,"保持状态：如果一个类有多个实例，那么它们的状态可能是不同的。使用单例模式可以确保所有实例共享相同的状态，从而避免状态不一致的问题。"),t("li",null,"工具类的使用场景, 写单例模式可以节省内存, 如果直接写 static 方法比较占内存, 使用单例的时候才会加载到内存, 当对象不用了的时候 gc 会吧方法回收, 效率高. 单例是类实例，占用的内存空间是堆空间，而 static 修饰的则被加载置方法区，包括所有的方法；")],-1),c=t("p",null,"总之，单例模式可以确保一个类只有一个实例，并提供全局访问点来访问该实例。这可以避免资源竞争、节省内存、统一访问和保持状态。在需要确保一个类只有一个实例并提供全局访问点的情况下，使用单例模式是一个不错的选择。",-1),i=[o,a,c];function _(r,d,p,u,m,f){return n(),l("div",null,i)}const D=e(s,[["render",_]]);export{v as __pageData,D as default};
